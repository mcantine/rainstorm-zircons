---
title: "SedimentTracers: Code for Cantine et al. in submission (Rainstorm)"
output:
  pdf_document: default
  html_notebook: default
---

```{r prepare environment, echo= FALSE, include=FALSE}

##In this chunk, the libraries used in the rest of the code are loaded, as well as a default color-blind palette I like to use. 

#Load my favorite libraries 
library("grid")
library("gridExtra")
library("ggplot2")
library("gdata")
library("dplyr")
library("MASS")
library('mixtools')
library('RColorBrewer')
library("scales")
library("reshape2")
library("Matrix")
library("cowplot")
library("matrixStats")
library("here")
library(MESS)


here() #This call sets the working directory to the current location of the file 

#colorblind palette
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

```


```{r Dietrich settling, echo = FALSE, warning=FALSE, include= FALSE}
#change include to TRUE if you want the plots generated in this section to appear in the knitted output 

#In this section, we begin working towards a figure showing the different settling velocities of zircon and quartz, depending on grain size and on fluid density (water vs air). To realize this, we use an empirically-informed relationship calculated by Dietrich 1982 which connects non-dimensional grain size (D*) to non-dimensional settling velocity (ws*). The results of Dietrich 1982 are generalizable beyond grains settling in water; however, we'll use a separate formulation, described later in this document, for the settling of grains in air for our final figure. But in this section, we will calculate the settling velocity of zircon and quartz grains in water and air using Dietrich's parameterization, and we will also check our output by comparing it to a figure generated by Dietrich. 

###
### Here, we define a few constants that will be used throughout this section. 
###

dynamic_v_water <- 1.002*10^-3 #at 20 degrees C and 1 atm; kg/m-s 
dynamic_v_water <- dynamic_v_water *10 #convert to g/cm-s

dynamic_v_air <- 1.825*10^-5 #at 20 degrees C and 1 atm; kg/m-s 
dynamic_v_air <- dynamic_v_air *10 #convert to g/cm-s

kinematic_v_air <- 1.516 * 10^-5 #m^2/s, kinematic viscosity of air at 20 deg C
kinematic_v_air <- kinematic_v_air * 10000 #convert to cm^2/s

kinematic_v_water <- 1.004 * 10^-6 #m^2/s, kinematic viscosity of water at 20 deg C
kinematic_v_water <- kinematic_v_water * 10000 #convert to cm^2/s

rho_air <- 1.204 #kg/m^3
rho_air <- rho_air / 1000 #g/cm^3

rho_water <- 1000 #kg/m^3
rho_water <- rho_water / 1000 #g/cm^3

rho_quartz <- 2650 #kg/m^3
rho_quartz <- rho_quartz / 1000 #g/cm^3

rho_zircon <- 4650 #kg/m^3
rho_zircon <- rho_zircon / 1000 #g/cm^3

g <- 9.80665 #m/s^2
g <- g * 100 #cm/s^2


#Corey Shape Factors
CSF_quartz <- 0.7 #estimate for natural grains
CSF_zircon <- 0.7 

#P = roundedness of grains; 0 = perfectly angular and 6.0 = perfectly smooth
#crushed grains are something like 2.0; 3.5 is used by Dietrich 1982 as an estimate for natural grains
P_quartz <- 3.5
P_zircon <- 3.5

###
### Now, begin calculating dimensionless quantities D* and ws* as defined by Dietrich 1982. 
###

#define a vector of diameters; this will be the x-axis of our final plot 
grain_size_vector <- 1:1000 #microns

#define a formula to find D*, the dimensionless grain size, Dietrich 1982 equation 6
#input as defined here is in cm, g, s --> output is dimensionless 
        dietrich_Dstar <- function(D, rho_mineral, rho_fluid, kinematic_v_fluid) {
          dstar <- (rho_mineral - rho_fluid) * g * (D^3)
          dstar <- dstar/(rho_fluid * kinematic_v_fluid^2)
          return(dstar)
        }
        
#Calculate D* for quartz + zircon in air + water; remember to convert grain size from microns to cm
Dstar_vector_quartz <- dietrich_Dstar(grain_size_vector/10000, rho_quartz, rho_water, kinematic_v_water) #convert diameter from microns into cm
Dstar_vector_quartz_air <- dietrich_Dstar(grain_size_vector/10000, rho_quartz, rho_air, kinematic_v_air) #convert diameter from microns into cm
Dstar_vector_zircon <- dietrich_Dstar(grain_size_vector/10000, rho_zircon, rho_water, kinematic_v_water) #convert diameter from microns into cm
Dstar_vector_zircon_air <- dietrich_Dstar(grain_size_vector/10000, rho_zircon, rho_air, kinematic_v_air) #convert diameter from microns into cm


# Dietrich 1982 uses 3 parameters to fit a regression of D* and ws* 
# They are R1, R2, and R3
# We will calculate them each individually for each value of D* 

        #R1 describes the role of grain density and size in determining settling velocity 
        #Equation 9 in Dietrich 1982 describes this relationship 
        #input and output are dimensionless quantities 
        dietrich_R1 <- function(dstar) {
          x <- log10(dstar)
          R1 <- (-3.76715 + 1.92944*x - 0.09815*x^2 - 0.00575*x^3 + 0.00056*x^4)
          return(R1)
        }
#Calculate R1 for quartz + zircon in water + air 
R1_quartz <- dietrich_R1(Dstar_vector_quartz) 
R1_quartz_air <- dietrich_R1(Dstar_vector_quartz_air) 
R1_zircon <- dietrich_R1(Dstar_vector_zircon) 
R1_zircon_air <- dietrich_R1(Dstar_vector_zircon_air) 
        
        #R2 describes the role of grain shape in determining settling velocity 
        #Equation 16 in Dietrich 1982 describes this relationship 
        #input and output are dimensionless quantities
                dietrich_R2 <- function(dstar, CSF) {
                  x <- log10(dstar)
                  R2 <- log10((1-(1-CSF)/0.85)) - (1-CSF)^(2.3) * tanh(x - 4.6) +(x-4.6)*0.3*(0.5-CSF)*(1-CSF)^(2)
                  return(R2)
                }

#Calculate R2 for quartz + zircon in water + air             
R2_quartz <- dietrich_R2(Dstar_vector_quartz, CSF_quartz) 
R2_quartz_air <- dietrich_R2(Dstar_vector_quartz_air, CSF_quartz) 
R2_zircon <- dietrich_R2(Dstar_vector_zircon, CSF_zircon) 
R2_zircon_air <- dietrich_R2(Dstar_vector_zircon_air, CSF_zircon) 

        #R3 describes the role of grain angularity in determining settling velocity 
        #Equation 18 in Dietrich 1982 describes this relationship 
        #input and output are dimensionless quantities
                dietrich_R3 <- function(dstar, CSF, P) {
                  x <- log10(dstar)
                  R3 <- (0.65 - (tanh(x - 4.6)*CSF/2.83))^(1 + (3.5-P)/2.5)
          return(R3)
                }
                
#Calculate R3 for quartz + zircon in water + air      
R3_quartz <- dietrich_R3(Dstar_vector_quartz, CSF_quartz, P_quartz) #convert diameter from microns into cm
R3_quartz_air <- dietrich_R3(Dstar_vector_quartz_air,  CSF_quartz, P_quartz) #convert diameter from microns into cm
R3_zircon <- dietrich_R3(Dstar_vector_zircon,  CSF_zircon, P_zircon) #convert diameter from microns into cm
R3_zircon_air <- dietrich_R3(Dstar_vector_zircon_air,  CSF_zircon, P_zircon) #convert diameter from microns into cm    
          

        #Equation 19 in Dietrich 1982 describes how R1, R2 and R3 interact with D* to yield ws* 
        #input and output are dimensionless quantities
                dietrich_final <- function(R1, R2, R3) {
                  Wstar <- R3*10^(R1 + R2)
                  return(Wstar)}
                
#Calculate W* for zircon and quartz in air and water             
Wstar_vector_quartz <- dietrich_final(R1_quartz, R2_quartz, R3_quartz)
Wstar_vector_quartz_air <- dietrich_final(R1_quartz_air, R2_quartz_air, R3_quartz_air)
Wstar_vector_zircon <- dietrich_final(R1_zircon, R2_zircon, R3_zircon)
Wstar_vector_zircon_air <- dietrich_final(R1_zircon_air, R2_zircon_air, R3_zircon_air)

        #Now we dimensionalize these quantities 
        #We use equation 5 from Dietrich to solve for ws from ws*
        #This gives us the y-axis for the graph we want to make 
        #input is in g, cm, s --> output in cm/s
        dietrich_w <- function(Wstar, rho_mineral, rho_fluid, kinematic_v_fluid) {
          ws <- Wstar * (rho_mineral - rho_fluid) * g * kinematic_v_fluid
          ws <- ws/rho_fluid
          ws <- (ws)^(1/3)
          return(ws)
        }

#Solve for ws for quartz and zircon in air and water      
ws_vector_quartz <- dietrich_w(Wstar_vector_quartz, rho_quartz, rho_water, kinematic_v_water)  
ws_vector_quartz_air <- dietrich_w(Wstar_vector_quartz_air, rho_quartz, rho_air, kinematic_v_air)  
ws_vector_zircon <- dietrich_w(Wstar_vector_zircon, rho_zircon, rho_water, kinematic_v_water)  
ws_vector_zircon_air <- dietrich_w(Wstar_vector_zircon_air, rho_zircon, rho_air, kinematic_v_air)  

#combine these data together into a single data table for plotting purposes 
dietrich_data <- data.frame(grain_size_vector, 
                             ws_vector_quartz, 
                             ws_vector_quartz_air, 
                             ws_vector_zircon, 
                             ws_vector_zircon_air)
#rename the variables 
names(dietrich_data) <- c('grain_diameter', 'quartz_water', 'quartz_air', 'zircon_water', 'zircon_air')

#define colors for plotting
colors <- c('grain_diameter' = 'black', 'quartz_water' = 'blue', 'quartz_air' = 'orange', 'zircon_water' = 'blue', 'zircon_air' = 'orange')
#plot the result 
Dietrich_plot <-ggplot(dietrich_data, aes(x = grain_diameter, y = ws_vector_quartz_air)) + 
  theme_bw() +
     theme(aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 10),
         axis.text.y = element_text(color = 'black', size = 10), 
         axis.ticks = element_line(color = "black")) +
  geom_line(dietrich_data, mapping = aes(y = quartz_air, x = grain_diameter, color = 'quartz_air'), size = .5)  +
  geom_line(dietrich_data, mapping = aes(y = zircon_air, x = grain_diameter, color = 'zircon_air'), size = .5,linetype='dashed' ) + 
    geom_line(dietrich_data, mapping = aes(y = quartz_water, x = grain_diameter, color = 'quartz_water'), size = .5)  +
  geom_line(dietrich_data, mapping = aes(y = zircon_water, x = grain_diameter, color = 'zircon_water'),linetype='dashed', size = .5)  +
     theme(aspect.ratio=1) +
   ggtitle('Dietrich settling velocities') +
  xlab('grain size, microns')+ 
  ylab('settling velocity, cm/s') + 
    scale_color_manual(values = colors) +
    scale_x_continuous(expand = c(0,0), position = "bottom", limits = c(1, 500))+
   scale_y_continuous(expand = c(0,0), trans = "log10", limits = c(.0001, 1000))
plot(Dietrich_plot)

#combine dimensionless data together into a single data table for plotting purposes 
dimensionless_data <- data.frame(Dstar_vector_quartz, Dstar_vector_quartz_air, Dstar_vector_zircon, Dstar_vector_zircon_air, Wstar_vector_quartz, Wstar_vector_quartz_air, Wstar_vector_zircon, Wstar_vector_zircon_air)

#This plots D* against Ws* for comparison/checking against Dietrich 1982 figure 5, which plots the same quantities.
# All lines should plot on top of each other. 
Dietrich_check_plot <-ggplot(dimensionless_data, aes(x = Dstar_vector_quartz, y = Wstar_vector_quartz)) + 
  theme_bw() +
     theme(aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 10),
         axis.text.y = element_text(color = 'black', size = 10), 
         axis.ticks = element_line(color = "black")) +
        geom_line(dimensionless_data, mapping = aes(y = Wstar_vector_quartz, x = Dstar_vector_quartz), size = .5, color = "black") + 
        geom_line(dimensionless_data, mapping = aes(y = Wstar_vector_quartz_air, x = Dstar_vector_quartz_air), size = .5, color = "gray") +
        geom_line(dimensionless_data, mapping = aes(y = Wstar_vector_zircon, x = Dstar_vector_zircon), size = .5, color = "blue") +  
        geom_line(dimensionless_data, mapping = aes(y = Wstar_vector_zircon_air, x = Dstar_vector_zircon_air), size = .5, color = "orange") +
  theme(aspect.ratio=1) +
   ggtitle('Dietrich 1982 figure 5 comparison') +
  xlab('D*')+ 
  ylab('W*') + 
    scale_x_continuous(expand = c(0,0), trans = "log10", limits = c(10^-2, 10^10))+
   scale_y_continuous(expand = c(0,0), trans = "log10", limits = c(10^-6, 10^6))
plot(Dietrich_check_plot)


```

```{r Aeolian settling, echo = FALSE, warning=FALSE, include=FALSE}

# Dietrich 1982's regression is based on non-dimensionalized numbers. It should apply in all turbulent settings, regardless of the densities of fluids and particles. However, Dietrich 1982 was primarily concerned with the settling of quartz in water and the studies used in Dietrich 1982 were primarily focused on particles settling in fluids more dense than air. We investigate the predicted relationships between settling velocity and grain size for quartz and zircon settling in air using insights from Raffaele et al. 2020,  Clift and Gauvin 1971, and Bagheri and Bonadonna 2016, three studies which focus on particle behavior in gases. 

# The first thing we will do is compare the approaches of Dietrich 1982, Clift and Gauvin 1971, and Bagheri and Bonadonna 2016 to see if there is any major difference between them. This is only a bit tricky--Clift and Gauvin 1971 and Bagheri and Bonadonna 2016 work in Re (Reynolds number) vs Cd (drag coefficient), which can be converted into the nondimensional grain diameter (D*) and nondimensional settling velocity (W*) that Dietrich 1982 works in, but it takes a bit of doing. 

# In fact, we will convert these relationships into dimensional grain size vs dimensional settling velocity--a space that is intuitive and has obvious physical interpretation for sedimentologists. 

###
### First up is Dietrich 1982. Lucky for us, we did this already in the chunk above. We will continue to use the dataframe dietrich_data for our analyses here. 
###


###
### So let's move on to our next study: we'll calculate D* and W* for Clift and Gauvin 1971 from their proposed relationship between Re (particle Reynolds number) and Cd (the coefficient of drag).  
###

# Define a vector of Reynolds numbers. We will use this to calculate the coefficient of drag later. 
Re.vector <- exp(log(10)*seq(log10(10^-6),log10(3.7*10^5),by=0.01)) #dimensionless


# Raffaele et al. 2020 present both Clift and Gauvin's original 1971 coefficients and new coeffecients calculated through statistical analysis of a broader set of data. Here, we provide functions that allow the user to calculate Cd using either the original or the 2020 coefficients. 

        #Calculation of Cd, Raffaele et al. 2020, equation 8 after Clift and Gauvin 1971
        #input and output are dimensionless
        Cd_clift_original <- function(Re) {
          ks1 = 1 #original Clift and Gauvin coefficient
          ks2 = 0.15 #original Clift and Gauvin coefficient
          ks3 = 0.687 #original Clift and Gauvin coefficient
          kn1 = 0.42 #original Clift and Gauvin coefficient
          kn2 = 42500 #original Clift and Gauvin coefficient
          kn3 = 1.16 #original Clift and Gauvin coefficient
          Cd <- (24/Re)*(ks1 + ks2*(Re^ks3)) + (kn1)/(1+(kn2/(Re^kn3)))
          return(Cd)
        }
        
        #Calculation of Cd, Raffaele et al. 2020, equation 8 after Clift and Gauvin 1971
        #input and output are dimensionless
        Cd_clift_fitted <- function(Re) {
          ks1 = 1.24 #fitted parameter from Raffaele et al. 2020; corrected value from pers. comm. with L. Raffaele 8 July 2020
          ks2 = 0.2951 #fitted parameter from Raffaele et al. 2020; corrected value from pers. comm. with L. Raffaele 8 July 2020
          ks3 = 0.6395 #fitted parameter from Raffaele et al. 2020; corrected value from pers. comm. with L. Raffaele 8 July 2020
          kn1 = 0.8327 #fitted parameter from Raffaele et al. 2020
          kn2 = 9849 #fitted parameter from Raffaele et al. 2020
          kn3 = 1.4104 #fitted parameter from Raffaele et al. 2020
          Cd <- (24/Re)*(ks1 + ks2*(Re^ks3)) + (kn1)/(1+(kn2/(Re^kn3)))
          return(Cd)
        }

        
# Our analysis will proceed using the fitted, Raffaele et al. 2020 parameters. 
        
#Calculate Cd for our vector of Re. 
Cd.vector.clift.fitted <- Cd_clift_fitted(Re.vector)

#We want to put this into Wstar and Dstar so we can compare the results to Dietrich 1982. 
Clift_Wstar_fitted <- (4/3) * Re.vector/Cd.vector.clift.fitted #equations 5 and 6 from Dietrich 1982 convert Re+Cd to D*+W*
Clift_Dstar_fitted <- (3/4) * Cd.vector.clift.fitted * Re.vector^2 #equations 5 and 6 from Dietrich 1982 convert Re+Cd to D*+W*

# Now let's calculate dimensional grain size and settling velocity using the relationships laid out by Dietrich 1982 and the function for calculating dimensional settling velocity laid out above. 
Clift_w_fitted_air_quartz <- dietrich_w(Clift_Wstar_fitted, rho_quartz, rho_air, kinematic_v_air) #output is in cm/s
Clift_w_fitted_water_quartz <- dietrich_w(Clift_Wstar_fitted, rho_quartz, rho_water, kinematic_v_water) #output is in cm/s
Clift_w_fitted_water_zircon <- dietrich_w(Clift_Wstar_fitted, rho_zircon, rho_water, kinematic_v_water) #output is in cm/s
Clift_w_fitted_air_zircon <- dietrich_w(Clift_Wstar_fitted, rho_zircon, rho_air, kinematic_v_air) #output is in cm/s
  
#Now we use equation 6 from Dietrich to solve for d from d*. 
        dietrich_d <- function(Dstar, rho_mineral, rho_fluid, kinematic_v_fluid) {
          d1 <- Dstar * rho_fluid * kinematic_v_fluid^2
          d2 <- (rho_mineral - rho_fluid) * g
          d <- (d1/d2)^(1/3)
          return(d)
        }

Clift_D_fitted_air_quartz <- dietrich_d(Clift_Dstar_fitted, rho_quartz, rho_air, kinematic_v_air) * 10000 #output is cm, convert to micron
Clift_D_fitted_water_quartz <- dietrich_d(Clift_Dstar_fitted, rho_quartz, rho_water, kinematic_v_water) * 10000 #output is cm, convert to micron
Clift_D_fitted_air_zircon <- dietrich_d(Clift_Dstar_fitted, rho_zircon, rho_air, kinematic_v_air) * 10000 #output is cm, convert to micron
Clift_D_fitted_water_zircon <- dietrich_d(Clift_Dstar_fitted, rho_zircon, rho_water, kinematic_v_water) * 10000 #output is cm, convert to micron

#Great. Now we have dimensional grain size and settling velocity for quartz and zircon in air and water from Clift and Gavuin 1971. 

###
### Now we'll calculate Cd using the Bagheri and Bonadonna 2016 formulation.
###


#Calculation of Cd, Raffaele et al. 2020, equation 9 after Bagheri and Bonadonna 2016. Again, we are using the new coefficients for this relationship as calculated in Raffaele et al. 2020. 

        #input and output are dimensionless
        Cd_bagheri <- function(Re) {
          ks = 1.2807 #coefficient as stated in Raffaele et al. 2020
          kn = 2.6893 #coefficient as stated in Raffaele et al. 2020
          cd1 <- 1+ 0.125 * (Re * kn/ks)^(2/3)
          cd2 <- (24 * ks)/(Re * kn) * cd1
          cd3 <- cd2 + 0.46/(1 + (5330/(Re*kn/ks)))
          Cd <- cd3 * kn
          return(Cd)
        }

#Calculate Cd for our vector of Re
Cd.vector.bagheri <- Cd_bagheri(Re.vector) #dimensionless number

#Convert Cd and Re into W* and D* for comparison with Dietrich 1982 data 
Bagheri_Wstar <- (4/3) * Re.vector/Cd.vector.bagheri #equations 5 and 6 from Dietrich 1982 convert Re+Cd to D*+W*
Bagheri_Dstar <- (3/4) * Cd.vector.bagheri * Re.vector^2 

# Now let's calculate dimensional grain size and settling velocity 
Bagheri_w_quartz_air <- dietrich_w(Bagheri_Wstar, rho_quartz, rho_air, kinematic_v_air) #output is in cm/s
Bagheri_w_zircon_air <- dietrich_w(Bagheri_Wstar, rho_zircon, rho_air, kinematic_v_air) #output is in cm/s
Bagheri_w_quartz_water <- dietrich_w(Bagheri_Wstar, rho_quartz, rho_water, kinematic_v_water) #output is in cm/s
Bagheri_w_zircon_water <- dietrich_w(Bagheri_Wstar, rho_zircon, rho_water, kinematic_v_water) #output is in cm/s

Bagheri_D_quartz_air <- dietrich_d(Bagheri_Dstar, rho_quartz, rho_air, kinematic_v_air) #output is cm
Bagheri_D_quartz_air <- Bagheri_D_quartz_air * 10000 #convert to micron
Bagheri_D_zircon_air <- dietrich_d(Bagheri_Dstar, rho_zircon, rho_air, kinematic_v_air) #output is cm
Bagheri_D_zircon_air <- Bagheri_D_zircon_air * 10000 #convert to micron
Bagheri_D_quartz_water <- dietrich_d(Bagheri_Dstar, rho_quartz, rho_water, kinematic_v_water) #output is cm
Bagheri_D_quartz_water <- Bagheri_D_quartz_water * 10000 #convert to micron
Bagheri_D_zircon_water <- dietrich_d(Bagheri_Dstar, rho_zircon, rho_water, kinematic_v_water) #output is cm
Bagheri_D_zircon_water <- Bagheri_D_zircon_water * 10000 #convert to micron


#Build data tables with all calculations for plotting. 
ReCd_data <- data.frame(Re.vector, Cd.vector.bagheri, Cd.vector.clift.fitted)
comparison_data <- data.frame(Bagheri_Dstar, Bagheri_Wstar, Clift_Dstar_fitted, Clift_Wstar_fitted)

dimensional_data <- data.frame(Clift_D_fitted_water_zircon,
                               Clift_D_fitted_air_zircon,
                               Clift_D_fitted_air_quartz,
                               Clift_D_fitted_water_quartz,
                               Clift_w_fitted_water_zircon, 
                               Clift_w_fitted_air_quartz, 
                               Clift_w_fitted_air_zircon, 
                               Clift_w_fitted_water_quartz,
                               Bagheri_D_quartz_air,
                               Bagheri_D_quartz_water,
                               Bagheri_D_zircon_air,
                               Bagheri_D_zircon_water,
                               Bagheri_w_quartz_air,
                               Bagheri_w_quartz_water,
                               Bagheri_w_zircon_air,
                               Bagheri_w_zircon_water)

#Plot and compare. Note that the behavior of all curves is similar with some divergence at high Re. Clift and Gavuin 1971 overlap with Bagheri and Bonadonna 2016; thus the Clift and Gauvin line is plotted with a thicker line so it remains visible after the Bagheri and Bonadonna line is plotted on top of it.       
Compare_dimensional_plot <- ggplot(dietrich_data, mapping = aes(x = grain_diameter, y = Dietrich_W_quartz_water)) +
  theme_bw() +
     theme(aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 10),
         axis.text.y = element_text(color = 'black', size = 10),
         axis.ticks = element_line(color = "black")) +
        geom_line(dietrich_data, mapping = aes(x = grain_diameter, y = quartz_air), size = .5, color = "black")  +
        geom_line(dietrich_data, mapping = aes(x = grain_diameter, y = zircon_air), size = .5, color = "black")  +
        geom_line(dietrich_data, mapping = aes(x = grain_diameter, y = quartz_water), size = .5, color = "black")  +
        geom_line(dietrich_data, mapping = aes(x = grain_diameter, y = zircon_water), size = .5, color = "black")  +
        geom_line(dimensional_data, mapping = aes(x = Clift_D_fitted_water_zircon, y = Clift_w_fitted_water_zircon), size = 1, color = "blue")  +
      geom_line(dimensional_data, mapping = aes(x = Clift_D_fitted_air_zircon, y = Clift_w_fitted_air_zircon), size = 1, color = "blue")  +
      geom_line(dimensional_data, mapping = aes(x = Clift_D_fitted_air_quartz, y = Clift_w_fitted_air_quartz), size = 1, color = "blue")  +
      geom_line(dimensional_data, mapping = aes(x = Clift_D_fitted_water_quartz, y = Clift_w_fitted_water_quartz), size = 1, color = "blue")  +
      geom_line(dimensional_data, mapping = aes(x = Bagheri_D_quartz_water, y = Bagheri_w_quartz_water), size = .5, color = "orange")  +
      geom_line(dimensional_data, mapping = aes(x = Bagheri_D_quartz_air, y = Bagheri_w_quartz_air), size = .5, color = "orange")  +
      geom_line(dimensional_data, mapping = aes(x = Bagheri_D_zircon_water, y = Bagheri_w_zircon_water), size = .5, color = "orange")  +
      geom_line(dimensional_data, mapping = aes(x = Bagheri_D_zircon_air, y = Bagheri_w_zircon_air), size = .5, color = "orange")  +
      theme(aspect.ratio=1) +
    ggtitle('Comparison') +
    xlab('microns')+
    ylab('settling velocity, cm/s') +
    scale_x_continuous(expand = c(0,0), position = "bottom", limits = c(1, 500))+
    scale_y_continuous(expand = c(0,0), trans = "log10", limits = c(.0001, 1000))

plot(Compare_dimensional_plot)


#Plots Re vs Cd for comparison to Fig 2a in Raffaele et al. 2020. 
#The published coefficients for Clift and Gauvin 1971 in Rffaele et al. 2020 are incorrect. They are corrected in this script following personal communication with L. Raffaele in July 2020. This plot allows the user to compare results with figure 2a in Raffaele et al. 2020. 
Raffaele_check_plot <- ggplot(ReCd_data, aes(x = Re.vector, y = Cd.vector.bagheri)) +
      geom_line(aes(x = Re.vector, y = Cd.vector.bagheri), color = 'red') +
      geom_line(aes(x = Re.vector, y = Cd.vector.clift.fitted), color = 'blue') +
      scale_x_continuous(trans = "log10", limits = c(10^-2, 10^5), expand = c(0,0), breaks = c(10^-2, 10^-1, 10^0, 10^1, 10^2, 10^3, 10^4, 10^5)) +
      scale_y_continuous(trans = "log10", limits = c(10^-1, 10^4), expand = c(0,0), breaks = c(10^-1, 10^0, 10^1, 10^2, 10^3, 10^4)) +
      xlab('Re')+ 
      ylab('Cd') 

#plot(Raffaele_check_plot)
        
```

```{r Fig. 1 Settling velocity, echo=FALSE, warning=FALSE}

# Rationale: We now work towards a plot showing settling velocity as a function of grain size. We will plot different curves that correspond to the density and fluid properties of zircon and quartz in air and water. We will use Dietrich 1982 for water-laid sediments and Bagheri and Bonadonna 2016 for air-laid sediments. 


colors <- c('grain_diameter' = 'black', 'quartz_water' = 'blue', 'quartz_air' = 'orange', 'zircon_water' = 'blue', 'zircon_air' = 'orange')
Settling_plot <-ggplot(dietrich_data, aes(x = grain_diameter, y = quartz_water)) + 
          theme_bw() +
          theme(aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm")) +
         geom_line(dietrich_data, mapping = aes(y = quartz_water, x = grain_diameter), size = .5, color = 'blue')  +
        geom_line(dietrich_data, mapping = aes(y = zircon_water, x = grain_diameter),linetype='dashed', color = 'blue', size = .5)  +
        geom_line(dimensional_data, mapping = aes(x = Bagheri_D_quartz_air, y = Bagheri_w_quartz_air), size = .5, color = "orange")  +
         geom_line(dimensional_data, mapping = aes(x = Bagheri_D_zircon_air, y = Bagheri_w_zircon_air), size = .5, color = "orange", linetype='dashed')  +
        theme(aspect.ratio=1) +
        ggtitle('') +
        xlab('grain diameter, microns')+ 
        ylab('settling velocity, cm/s') + 
        scale_color_manual(values = colors) +
        scale_x_continuous(expand = c(0,0), 
                       position = "bottom", 
                       sec.axis = sec_axis(trans=~.*1),
                       limits = c(0, 500))+
        scale_y_continuous(expand = c(0,0), 
                      trans = "log10", 
                      limits = c(.0001, 1000), 
                      sec.axis = sec_axis(trans=~.*1, breaks = trans_breaks("log10", function(x) 10^x)),
                      breaks = trans_breaks("log10", function(x) 10^x),
                      labels = trans_format("log10", math_format(10^.x)))   
plot(Settling_plot)


ggsave("SettlingVelocities_plot.pdf", Settling_plot, width = 8.8, height = 8.8, units = "cm")


```

```{r Figs. 5-6-7 Rainstorm Size and Age, echo=FALSE}

# In this section, we look at the measured ages and sizes of grains from the Death Valley succession, both analyzed by me and by Schoenborn et al. 2010. and by Muhlbauer et al. 2017.

#Load the data. 
Grain_data <- read.xls('Grain_data_Supplement_Size_and_Age_v03.xlsx',1, verbose=FALSE, skip = 0) #read file
Grain_data <- Grain_data[,1:14] #trim the data 
names(Grain_data) <- c('spot_name', 'name2', 'analysisname', 'age207206', 'sd1_age207206', 'age238206', 'sd1_age238206', 'concordance', 'long_axis', 'short_axis', 'esd', 'bin', 'source', 'sample') #give columns names 

#convert numerical columns to numbers not strings
Grain_data$concordance <- as.numeric(as.character(Grain_data$concordance))
Grain_data$esd <- as.numeric(as.character(Grain_data$esd))
Grain_data$long_axis <- as.numeric(as.character(Grain_data$long_axis))
Grain_data$short_axis <- as.numeric(as.character(Grain_data$short_axis))
Grain_data$age207206 <- as.numeric(as.character(Grain_data$age207206))
Grain_data$sd1_age207206 <- as.numeric(as.character(Grain_data$sd1_age207206))
Grain_data$age238206 <- as.numeric(as.character(Grain_data$age238206))
Grain_data$sd1_age238206 <- as.numeric(as.character(Grain_data$sd1_age238206))

#remove samples with discordance > 10% absolute value 
#This is manually calculated for Cantine and Schoenborn samples. Muhlbauer samples are all concordant.
Grain_data <- subset(Grain_data, abs(Grain_data$concordance) < 0.1)

# create a new column, agebin, and fill it in with categories for different age groups 
Grain_data$agebin <- 0
Grain_data$agebin[Grain_data$age207206 < 1200] <- "<1200"
Grain_data$agebin[Grain_data$age207206 < 1500 & Grain_data$age207206 >= 1200] <- "1200-1500" 
Grain_data$agebin[Grain_data$age207206 < 1900 & Grain_data$age207206 >= 1500] <- "1500-1900" 
Grain_data$agebin[Grain_data$age207206 > 1900] <- ">1900" 


# Make a violin plot based on the column agebin
age_v_size_plot <-ggplot(Grain_data, aes(x = age207206, y = long_axis, group = agebin)) +
                  geom_violin(aes(x = age207206, y = long_axis))+
                  scale_x_continuous(expand = c(0,0), 
                     limits = c(0, 4000),
                     sec.axis = sec_axis(trans=~.*1))+
                  scale_y_continuous(expand = c(0,0), 
                      limits = c(0,400),
                      sec.axis = sec_axis(trans=~.*1))+ 
                  xlab('age') +
                  ylab('long axis, microns') +
                  ggtitle('') +
                  theme_bw() +
                  theme(aspect.ratio= 1,
                   panel.grid.major = element_blank(),
                   panel.grid.minor = element_blank(),
                   panel.border  = element_rect(colour = "black", fill=NA, size=1),
                   axis.line = element_line(colour = "black"),
                   axis.text.x = element_text(color = 'black', size = 12, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
                   axis.text.y = element_text(color = 'black', size = 12, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
                   axis.ticks = element_line(color = "black"), 
                   plot.title = element_text(size = 12),
                   panel.background = element_blank(),
                   axis.text.x.top = element_blank(), 
                   axis.text.y.right = element_blank(), 
                   axis.ticks.x.top = element_line(color = "black"),
                   axis.ticks.y.right = element_line(color = "black"),
                   axis.ticks.length=unit(-0.25, "cm") )

# save the box and whisker plot down. 
ggsave("Age_v_size_R_output.pdf", age_v_size_plot, width = 8.8, height = 8.8, units = "cm")

# For the next bit, we will be working to plot size histograms  and age spectra for all samples. 
# we use the unique() command to yield a list of sample names 
sample_list <- unique(Grain_data$bin)

# We use that list of sample names to plot size histograms and age spectra in a loop for all samples 
for (i in seq_along(sample_list)) { 
  
##Give the name of the plot
name_of_size_plot <- paste("Rainstorm_size_plot_", as.character(sample_list[i]), sep ="")

##Plot size histograms for all samples 
name_of_size_plot <-ggplot(subset(Grain_data, Grain_data$bin==sample_list[i]), aes(x = long_axis)) +
                      geom_histogram(binwidth = 10)+
                      scale_x_continuous(expand = c(0,0), limits = c(0, 400), sec.axis = sec_axis(trans=~.*1))+
                      scale_y_continuous(expand = c(0,0), limits = c(0,25), sec.axis = sec_axis(trans=~.*1))+ 
                      xlab('grain size, microns') +
                      ggtitle(sample_list[i]) +
                      theme_bw() +
                      theme(aspect.ratio= 1/4,
                     panel.grid.major = element_blank(),
                     panel.grid.minor = element_blank(),
                     panel.border  = element_rect(colour = "black", fill=NA, size=1),
                     axis.line = element_line(colour = "black"),
                     axis.text.x = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
                     axis.text.y = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
                     axis.ticks = element_line(color = "black"), 
                     plot.title = element_text(size = 12),
                     panel.background = element_blank(),
                     axis.text.x.top = element_blank(), 
                     axis.text.y.right = element_blank(), 
                     axis.ticks.x.top = element_line(color = "black"),
                     axis.ticks.y.right = element_line(color = "black"),
                     axis.ticks.length=unit(-0.1, "cm"))

#Give the name of the age spectra plot 
name_of_age_plot <- paste("Rainstorm_age_plot_", as.character(sample_list[i]), sep ="")

#calculate PDF for zircons in sample 
age_range = 0:4000
zircons <- subset(Grain_data, Grain_data$bin==sample_list[i])
PDF_zircons <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=zircons$age207206, sd=zircons$sd1_age207206)
PDF_zircons <- rowSums(PDF_zircons, na.rm = FALSE, dims = 1)
PDF_zircons <- PDF_zircons / nrow(zircons) 
PDF_zircons <- data.frame(age_range, PDF_zircons)

#generate age PDF plot
name_of_age_plot <-ggplot(PDF_zircons) + 
        geom_line(aes(x = age_range, y = PDF_zircons), size = .5, color = "black")  +
        scale_x_continuous(expand = c(0,0), 
                           limits = c(0, 4000), 
                           sec.axis = sec_axis(trans=~.*1))+
        scale_y_continuous(expand = c(0,0), 
                           limits = c(0,0.01), 
                           breaks = c(0, 0.005, 0.01), 
                           sec.axis = sec_axis(trans=~.*1,  breaks = c(0, 0.005, 0.01)))+ 
        ggtitle(sample_list[i]) +
        xlab('Ma')+
        ylab('Probability') +
        theme_bw() +
        theme(aspect.ratio= 1/4,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
         axis.text.y = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
         axis.ticks = element_line(color = "black"), 
         plot.title = element_text(size = 12),
         panel.background = element_blank(),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.1, "cm"))

#save the age plot and size plot as a pdf 
ggsave(paste("Rainstorm_age_plot_", as.character(sample_list[i]), ".pdf", sep =""), name_of_age_plot, width = 8, units = "cm")  
ggsave(paste("Rainstorm_size_plot_", as.character(sample_list[i]), ".pdf", sep =""), name_of_size_plot, width = 8,units = "cm")
}

#Separate all grains by size. 
Grain_silt <- subset(Grain_data, Grain_data$long_axis < 63.5)
silt <- ecdf(Grain_silt$age207206)
Grain_vf_sand <- subset(Grain_data, Grain_data$long_axis > 63.5 & Grain_data$long_axis < 125)
vf_sand <- ecdf(Grain_vf_sand$age207206)
Grain_f_sand <- subset(Grain_data, Grain_data$long_axis > 125 & Grain_data$long_axis < 250)
f_sand <- ecdf(Grain_f_sand$age207206)
Grain_m_sand <- subset(Grain_data, Grain_data$long_axis > 250 & Grain_data$long_axis < 500)
m_sand <- ecdf(Grain_m_sand$age207206)

#Perform K-S tests on the size classes.
ks.test(Grain_silt$age207206, Grain_vf_sand$age207206)
ks.test(Grain_silt$age207206, Grain_f_sand$age207206)
ks.test(Grain_silt$age207206, Grain_m_sand$age207206)

ks.test(Grain_vf_sand$age207206, Grain_f_sand$age207206)
ks.test(Grain_vf_sand$age207206, Grain_m_sand$age207206)

ks.test(Grain_f_sand$age207206, Grain_m_sand$age207206)


###Now make a empirical cumulative distribution function plot. 
ECDF_samples <-ggplot(Grain_data) + 
  stat_ecdf(Grain_silt, mapping = aes(x =Grain_silt$age207206), size = .5, color = 'gray0')  +
  stat_ecdf(Grain_vf_sand, mapping = aes(x =Grain_vf_sand$age207206), size = .5, color = 'gray36', linetype="dashed")  +
   stat_ecdf(Grain_f_sand, mapping = aes(x =Grain_f_sand$age207206), size = .5, color = 'gray60', linetype = "dotted")  +
   stat_ecdf(Grain_m_sand, mapping = aes(x =Grain_m_sand$age207206), size = .5, color = 'gray80', linetype="twodash")  +
    scale_x_continuous(expand = c(0,0), limits = c(500, 3500), sec.axis = sec_axis(trans=~.*1))+
    scale_y_continuous(expand = c(0,0), limits = c(0,1), breaks = c(0, 0.5,1.0), sec.axis = sec_axis(trans=~.*1,  breaks = c(0, 0.5, 1)))+ 
    xlab('Ma')+
    ylab('%') +
    theme_bw() +
    theme(aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
         axis.text.y = element_text(color = 'black', size = 8, margin=unit(c(0.25, 0.25,0.25,0.25), "cm")),
         axis.ticks = element_line(color = "black"), 
         plot.title = element_text(size = 12),
         panel.background = element_blank(),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.1, "cm"))


ggsave("ECDF_samples.pdf", ECDF_samples, width = 8, height = 10, units = "cm")


```

```{r Fig 3 LPSA Data, echo=FALSE, warning=FALSE}
### Rationale: make plots of LPSA-acquired grain size information for heavy and light Rainstorm fractions

#Start with sink data
LPSA_Data_Sink <- read.xls('OklahomaLPSA.xlsx',2, verbose=FALSE, skip = 0) #read file
LPSA_Data_Sink <- data.frame(LPSA_Data_Sink[4:103,18:21]) #trim file to averages over multiple runs
names(LPSA_Data_Sink) <- c("size_class_min","size_class_max", "vol_percent", "cum_vol_percent") #rename columns
#process columns so they are readable as numerical vectors by R
LPSA_Data_Sink$size_class_min <- as.numeric(as.character(LPSA_Data_Sink$size_class_min))
LPSA_Data_Sink$size_class_max <- as.numeric(as.character(LPSA_Data_Sink$size_class_max))
LPSA_Data_Sink$vol_percent <- as.numeric(as.character(LPSA_Data_Sink$vol_percent))
LPSA_Data_Sink$cum_vol_percent <- as.numeric(as.character(LPSA_Data_Sink$cum_vol_percent))

#Now the float data
LPSA_Data_Float <- read.xls('OklahomaLPSA.xlsx',3, verbose=FALSE, skip = 0) #read file
LPSA_Data_Float <- LPSA_Data_Float[4:103,18:21] #trim file to averages over multiple runs
names(LPSA_Data_Float) <- c("size_class_min","size_class_max", "vol_percent", "cum_vol_percent") #rename columns
#process columns so they are readable as numerical vectors by R
LPSA_Data_Float$size_class_min <- as.numeric(as.character(LPSA_Data_Float$size_class_min))
LPSA_Data_Float$size_class_max <- as.numeric(as.character(LPSA_Data_Float$size_class_max))
LPSA_Data_Float$vol_percent <- as.numeric(as.character(LPSA_Data_Float$vol_percent))
LPSA_Data_Float$cum_vol_percent <- as.numeric(as.character(LPSA_Data_Float$cum_vol_percent))

Sink_size_plot <-ggplot(LPSA_Data_Sink, aes(x = size_class_min, y = vol_percent)) +
  geom_rect(aes(xmin = size_class_min,xmax = size_class_max, ymin = 0, ymax = vol_percent)) +
  theme_bw() +
  #  geom_line(aes(x = size_class_min, y = LPSA_Data_Sink$pdf*500)) +
  theme(aspect.ratio=1) +
  scale_x_continuous(expand = c(0,0), 
                     limits = c(1, 400), 
                     trans = "log10", 
                     labels = scales::number_format(accuracy = 1), 
                     sec.axis = sec_axis(trans=~.*1))+
   scale_y_continuous(expand = c(0,0), 
                      limits = c(0, 10), 
                      breaks = c(0, 5, 10), 
                      labels = scales::number_format(accuracy = 1), sec.axis = sec_axis(trans=~.*1))+
  xlab('grain size, microns') +
  ylab('volume percent') +
  ggtitle('Sink') +
  theme(aspect.ratio= 1/2,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         axis.line = element_line(colour = "black", size=1),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
        axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.ticks = element_line(color = "black"), 
         plot.title = element_text(size = 12),
         panel.background = element_blank(),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm")) 

Float_size_plot <-ggplot(LPSA_Data_Float, aes(x = size_class_min, y = vol_percent)) +
  geom_rect(aes(xmin = size_class_min,xmax = size_class_max, ymin = 0, ymax = vol_percent)) +
  theme_bw() +
  theme(aspect.ratio=1) +
  scale_x_continuous(expand = c(0,0), 
                     limits = c(1, 400), 
                     trans = "log10", 
                     labels = scales::number_format(accuracy = 1), 
                     sec.axis = sec_axis(trans=~.*1))+
  scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 10),  
                     labels = scales::number_format(accuracy = 1), 
                     breaks = c(0, 5, 10), 
                     sec.axis = sec_axis(trans=~.*1))+
  xlab('') +
  ylab('volume percent') +
  ggtitle('Float') +
     theme(aspect.ratio= 1/2,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black", size=1),
         axis.text.x = element_text(color = 'black', size = 8, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 8, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.ticks = element_line(color = "black"), 
         plot.title = element_text(size = 12),
         panel.background = element_blank(),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm")) 


size_plot <- grid.arrange(
  grobs = list(Float_size_plot, Sink_size_plot),
  widths = c(1),
  heights = c(1,1),
  layout_matrix = rbind(c(1),
                        c(2)))

ggsave("RainstormSizes.pdf", size_plot, width = 8.8, height = 10, units = "cm")


```

```{r Fig 4 Imaginary grains, echo=FALSE, warning=FALSE}

# This part of the code explores the process-driven differences in size-density relationships that can lead to diffences in detrital zircon spectra.

#Define a palette to use, sampling from the colorblind palette from the set-up chunk above 
palette1 <- c(cbbPalette[4], cbbPalette[7])

set.seed(1) #set seed for reproducibility for the loops we will do in this section 

#Scaling factor for quartz
scaling_quartz = 5*10^5; #how many total quartz grains to generate in each source region


fraction_S1 = .5; #set the fraction of total quartz and zircon grains that should come from source 1 


#Below, the parameters for each case are defined. Comment out with # the cases you do not want to run. 

# #######BASE CASE
# ## plotting parameters
# plot_size_min <- 0
# plot_size_max <- 300
# ## modeling parameters
# ## Depositional sediment distribution for quartz in microns
# Deposit_mean_quartz = 200;
# Deposit_sd_quartz = 15;
# deposit_this_many_grains = 10000;
# ## Parameters for source region 1
# # fraction of sediment compared to other source regions
# # mineral fertility (ratio of quartz to other minerals)
# fertility_zircon_S1 = 1/10;
# # size paraneters of grains in microns
# SizeMean_quartz_S1 = 200; #mean
# SizeSD_quartz_S1 = 15; #standard deviation
# SizeMean_zircon_S1 = 150; #mean
# SizeSD_zircon_S1 = 15; #standard deviation
# 
# # Age population of grains, Ma
# AgeMean_quartz_S1 = 1000; #mean
# AgeSD_quartz_S1 = 50; #standard deviation
# AgeMean_zircon_S1 = 1000; #mean
# AgeSD_zircon_S1 = 50; #standard deviation
# 
# ## Parameters for source region 2
# # fraction of sediment compared to other source regions
# fraction_S2 = 1 - fraction_S1;
# # mineral fertility (ratio of quartz to other minerals)
# fertility_zircon_S2 = 1/10;
# 
# # size paraneters of grains in microns
# SizeMean_quartz_S2 = 200; #mean
# SizeSD_quartz_S2 = 15; #standard deviation
# SizeMean_zircon_S2 = 150; #mean
# SizeSD_zircon_S2 = 15; #standard deviation
# 
# 
# # Age population of grains, Ma
# AgeMean_quartz_S2 = 500; #mean
# AgeSD_quartz_S2 = 50; #standard deviation
# AgeMean_zircon_S2 = 500; #mean
# AgeSD_zircon_S2 = 50; #standard deviation

#######CASE 1: SAND, DIFFERENT ZIRCON SIZES, SMALLER S2
## plotting parameters
plot_size_min <- 0
plot_size_max <- 300
## modeling parameters
## Depositional sediment distribution for quartz in microns
Deposit_mean_quartz = 200;
Deposit_sd_quartz = 15;
deposit_this_many_grains = 10000;
## Parameters for source region 1
# fraction of sediment compared to other source regions
# mineral fertility (ratio of quartz to other minerals)
fertility_zircon_S1 = 1/10;
# size parameters of grains in microns
SizeMean_quartz_S1 = 200; #mean
SizeSD_quartz_S1 = 15; #standard deviation
SizeMean_zircon_S1 = 150; #mean
SizeSD_zircon_S1 = 15; #standard deviation

# Age population of grains, Ma
AgeMean_quartz_S1 = 1000; #mean
AgeSD_quartz_S1 = 50; #standard deviation
AgeMean_zircon_S1 = 1000; #mean
AgeSD_zircon_S1 = 50; #standard deviation

## Parameters for source region 2
# fraction of sediment compared to other source regions
fraction_S2 = 1 - fraction_S1;
# mineral fertility (ratio of quartz to other minerals)
fertility_zircon_S2 = 1/10;

# size paraneters of grains in microns
SizeMean_quartz_S2 = 200; #mean
SizeSD_quartz_S2 = 15; #standard deviation
SizeMean_zircon_S2 = 100; #mean
SizeSD_zircon_S2 = 15; #standard deviation


# Age population of grains, Ma
AgeMean_quartz_S2 = 500; #mean
AgeSD_quartz_S2 = 50; #standard deviation
AgeMean_zircon_S2 = 500; #mean
AgeSD_zircon_S2 = 50; #standard deviation

# ######CASE 2: SILT, DIFFERENT ZIRCON SIZES,  SMALLER S2
# ## plotting parameters
# plot_size_min <- 0
# plot_size_max <- 300
# ## modeling parameters
# ## Depositional sediment distribution for quartz in microns
# Deposit_mean_quartz = 55;
# Deposit_sd_quartz = 5;
# deposit_this_many_grains = 10000;
# ## Parameters for source region 1
# # fraction of sediment compared to other source regions
# # mineral fertility (ratio of quartz to other minerals)
# fertility_zircon_S1 = 1/10;
# # size parameters of grains in microns
# SizeMean_quartz_S1 = 80; #mean
# SizeSD_quartz_S1 = 15; #standard deviation
# SizeMean_zircon_S1 = 40; #mean
# SizeSD_zircon_S1 = 10; #standard deviation
# 
# # Age population of grains, Ma
# AgeMean_quartz_S1 = 1000; #mean
# AgeSD_quartz_S1 = 50; #standard deviation
# AgeMean_zircon_S1 = 1000; #mean
# AgeSD_zircon_S1 = 50; #standard deviation
# 
# ## Parameters for source region 2
# # fraction of sediment compared to other source regions
# fraction_S2 = 1 - fraction_S1;
# # mineral fertility (ratio of quartz to other minerals)
# fertility_zircon_S2 = 1/10;
# 
# # size paraneters of grains in microns
# SizeMean_quartz_S2 = 80; #mean
# SizeSD_quartz_S2 = 15; #standard deviation
# SizeMean_zircon_S2 = 30; #mean
# SizeSD_zircon_S2 = 10; #standard deviation
# 
# 
# # Age population of grains, Ma
# AgeMean_quartz_S2 = 500; #mean
# AgeSD_quartz_S2 = 50; #standard deviation
# AgeMean_zircon_S2 = 500; #mean
# AgeSD_zircon_S2 = 50; #standard deviation



## Generate grains from source region 1 
# generate grains 
Sizes_quartz_S1 = runif(scaling_quartz * fraction_S1, min = plot_size_min, max = plot_size_max)
#generate the sizes of all quartz grains from this region, randomly distributed around parameters identified above  
Ages_quartz_S1 = rnorm(scaling_quartz * fraction_S1, AgeMean_quartz_S1, AgeSD_quartz_S1) #generate the ages of all quartz grains from this region, randomly distributed around the parameters identified above 

AgesUncert_quartz_S1 = Ages_quartz_S1 * 0.025 #assume a 2-sd uncertainty of 5% on the measured age of each grain 
#generate zircon grains; 1 sd = 2.5%

Sizes_zircon_S1 = rnorm(scaling_quartz * fraction_S1 * fertility_zircon_S1, SizeMean_zircon_S1, SizeSD_zircon_S1) #generate the sizes of all zircon grains from this region, randomly distributed around paramters identified above 

Ages_zircon_S1 = rnorm(scaling_quartz * fraction_S1 * fertility_zircon_S1, AgeMean_zircon_S1, AgeSD_zircon_S1) #generate the ages of all zircon grains from this region, randomly distributed around the parameters identified above 

AgesUncert_zircon_S1 = Ages_zircon_S1 * 0.025 #assume an uncertainty of 5% on the measured age of each grain 

## Generate grains from source region 2 
# generate quartz grains 
Sizes_quartz_S2 = runif(scaling_quartz * fraction_S2, min = plot_size_min, max = plot_size_max)
#generate the sizes of all quartz grains from this region, randomly distributed around paramters identified above  
Ages_quartz_S2 = rnorm(scaling_quartz * fraction_S2, AgeMean_quartz_S2, AgeSD_quartz_S2) #generate the ages of all quartz grains from this region, randomly distributed around the parameters identified above 

AgesUncert_quartz_S2 = Ages_quartz_S2 * 0.025 #assume an uncertainty of 5% on the measured age of each grain 
#generate zircon grains 

Sizes_zircon_S2 = rnorm(scaling_quartz * fraction_S2 * fertility_zircon_S2, SizeMean_zircon_S2, SizeSD_zircon_S2) #generate the sizes of all zircon grains from this region, randomly distributed around paramters identified above 

Ages_zircon_S2 = rnorm(scaling_quartz * fraction_S2 * fertility_zircon_S2, AgeMean_zircon_S2, AgeSD_zircon_S2) #generate the ages of all zircon grains from this region, randomly distributed around the parameters identified above 

AgesUncert_zircon_S2 = Ages_zircon_S2 * 0.025; #assume an uncertainty of 5% on the measured age of each grain 

#Generate probability density functions for mineral populations
age.range = 0:2000; #this is the age ranges we will consider; forms the x-axis of many plots generated from this section

## for source region 1 
# for quartz
#calculate the probability distribution function of ages for quartz
#This does not have a real-world analytical counterpart--we do not measure the ages of quartz in detrital zircon studies, of course. However, it's built in here so it can function as a tracer if desired. 
PDF_quartz_S1 <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=Ages_quartz_S1, sd=AgesUncert_quartz_S1)
PDF_quartz_S1 <- rowSums(PDF_quartz_S1, na.rm = FALSE, dims = 1)
PDF_quartz_S1 <- PDF_quartz_S1 / length(Ages_quartz_S1) #in this case, should be length
PDF_quartz_S1<- data.frame(age.range, PDF_quartz_S1, "quartz")

#calculate the probability distribution function of ages for zircon
PDF_zircon_S1 <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=Ages_zircon_S1, sd=AgesUncert_zircon_S1)
PDF_zircon_S1 <- rowSums(PDF_zircon_S1, na.rm = FALSE, dims = 1)
PDF_zircon_S1 <- PDF_zircon_S1 / length(Ages_zircon_S1) #in this case, should be length
PDF_zircon_S1<- data.frame(age.range, PDF_zircon_S1, "zircon")

## for source region 2 
# See note above about the probability distribution function applied to quartz. 
PDF_quartz_S2 <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=Ages_quartz_S2, sd=AgesUncert_quartz_S2)
PDF_quartz_S2 <- rowSums(PDF_quartz_S2, na.rm = FALSE, dims = 1)
PDF_quartz_S2 <- PDF_quartz_S2 / length(Ages_quartz_S2) #in this case, should be length
PDF_quartz_S2<- data.frame(age.range, PDF_quartz_S2, "quartz")

#calculate the probability distribution function of ages for zircon
PDF_zircon_S2 <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=Ages_zircon_S2, sd=AgesUncert_zircon_S2)
PDF_zircon_S2 <- rowSums(PDF_zircon_S2, na.rm = FALSE, dims = 1)
PDF_zircon_S2 <- PDF_zircon_S2 / length(Ages_zircon_S2) #in this case, should be length
PDF_zircon_S2<- data.frame(age.range, PDF_zircon_S2, "zircon")

## Make data frames for different areas 

#for source area 1 
#quartz grains
Grains_quartz_S1 <- data.frame(Sizes_quartz_S1, Ages_quartz_S1, AgesUncert_quartz_S1, rep("quartz", times = length(Sizes_quartz_S1)), rep("S1", times = length(Sizes_quartz_S1))) #make a data frame for all quartz grains from S1, add rows 
names(Grains_quartz_S1) <- c("size", "age", "age_uncert", "mineral", "source")
#zircon grains
Grains_zircon_S1 <- data.frame(Sizes_zircon_S1, Ages_zircon_S1, AgesUncert_zircon_S1, rep("zircon", times = length(Sizes_zircon_S1)), rep("S1", times = length(Sizes_zircon_S1))) #make a data frame for all zircon grains from S1, add rows 
names(Grains_zircon_S1) <- c("size", "age", "age_uncert", "mineral", "source")


#for source area 2 
#quartz grains
Grains_quartz_S2 <- data.frame(Sizes_quartz_S2, Ages_quartz_S2, AgesUncert_quartz_S2, rep("quartz", times = length(Sizes_quartz_S2)), rep("S2", times = length(Sizes_quartz_S2))) #make a data frame for all quartz grains from S2, add rows 
names(Grains_quartz_S2) <- c("size", "age", "age_uncert", "mineral", "source")
#zircon grains
Grains_zircon_S2 <- data.frame(Sizes_zircon_S2, Ages_zircon_S2, AgesUncert_zircon_S2, rep("zircon", times = length(Sizes_zircon_S2)), rep("S2", times = length(Sizes_zircon_S2))) #make a data frame for all zircon grains from S2, add rows 
names(Grains_zircon_S2) <- c("size", "age", "age_uncert", "mineral", "source")

#Plot the sizes of all source 1 grains-- size vs number (a histogram)
Sizes_grains_plot_S1 <- ggplot(Grains_zircon_S1, aes(x=Sizes_zircon_S1)) + 
  geom_histogram(Grains_quartz_S2, mapping = aes(x=Sizes_quartz_S1), binwidth = 2, fill = palette1[1], alpha = 0.5) +
  geom_histogram(Grains_zircon_S2, mapping = aes(x=Sizes_zircon_S1), binwidth = 2, fill = palette1[1]) +
  #   theme(aspect.ratio=1) +
  ggtitle('Grain size') +
  xlab('')+
  ylab('number')  +
  scale_y_continuous(expand=c(0,0), 
                     limits=c(0,3000), 
                     sec.axis = sec_axis(trans=~.*1)) +
    scale_x_continuous(expand=c(0,0), 
                       limits = c(plot_size_min, plot_size_max), 
                       breaks = c(plot_size_min, (plot_size_min+ plot_size_max)/2, plot_size_max),
                       sec.axis = sec_axis(trans=~.*1)) +
   scale_fill_manual(values=palette1[2]) +
   theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
          plot.margin=unit(c(.25,0,0,0), "cm"),
         plot.background = element_blank())

#Plot the sizes of all source 2 grains-- size vs number (a histogram)
Sizes_grains_plot_S2 <- ggplot(Grains_zircon_S2, aes(x=Sizes_zircon_S2)) + 
  geom_histogram(Grains_quartz_S2, mapping = aes(x=Sizes_quartz_S2), binwidth = 2, fill = palette1[2], alpha = 0.5) +
  geom_histogram(Grains_zircon_S2, mapping = aes(x=Sizes_zircon_S2), binwidth = 2, fill = palette1[2]) +
  #   theme(aspect.ratio=1) +
  ggtitle('') +
  xlab('diameter, um')+
  ylab('number')  +
  scale_x_continuous(expand=c(0,0), 
                     limits = c(plot_size_min, plot_size_max), 
                     breaks = c(plot_size_min, (plot_size_min+ plot_size_max)/2, plot_size_max),
                     sec.axis = sec_axis(trans=~.*1)) +
  scale_y_continuous(expand=c(0,0), 
                     limits=c(0,3000),
                     sec.axis = sec_axis(trans=~.*1)) +
   scale_fill_manual(values=palette1[2]) +
   theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank())

#Plot the age spectra (aka probability distribution function) of all source 1 zircon grains 
Ages_zircon_plot_S1 <-ggplot(PDF_zircon_S1) + 
  geom_line(aes(x = age.range, y = PDF_zircon_S1), size = .5, color = palette1[1])  +
  ggtitle('Age spectra') +
  xlab('')+
  ylab('probability') +  
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001), 
                     expand = c(0,0), 
                     limits = c(0, 0.01), 
                     breaks = c(0, 0.005, 0.01),
                     sec.axis = sec_axis(trans=~.*1,  breaks = c(0, 0.005, 0.01))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
  scale_fill_manual(values=palette1[1]) +
  theme_bw() +
  theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.margin=unit(c(.25,0,0,0), "cm"),
         plot.background = element_blank())

#Plot the age spectra (aka probability distribution function) of all source 2 zircon grains
Ages_zircon_plot_S2 <-ggplot(PDF_zircon_S2) + 
  geom_line(aes(x = age.range, y = PDF_zircon_S2), size = .5, color = palette1[2])  +
  ggtitle('') +
  xlab('Ma')+
  ylab('probability') +
  scale_fill_manual(values=palette1[2]) +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001), 
                     expand = c(0,0), 
                     limits = c(0, 0.01), 
                     breaks = c(0, 0.005, 0.01),
                     sec.axis = sec_axis(trans=~.*1,  breaks = c(0, 0.005, 0.01))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
   scale_fill_manual(values=palette1[1]) +
   theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank())


#Combine all source areas into one dataframe
#First for quartz...
Grains_quartz_combined <- rbind(Grains_quartz_S1, Grains_quartz_S2) #combine the dataframes
Sources_quartz_combined <- Grains_quartz_combined %>% dplyr::count(source) #count the sources (should reflect the fraction_S1 you set above)

#Then for zircon...
Grains_zircon_combined <- rbind(Grains_zircon_S1, Grains_zircon_S2) #combine the dataframes
Sources_zircon_combined <- Grains_zircon_combined %>% dplyr::count(source) #count the sources (should reflect the 1 - fraction_S1 you set above)

#Define the normal distribution for the grain size of the deposited quartz
PDF_deposit_quartz <- dnorm(1:plot_size_max, Deposit_mean_quartz, Deposit_sd_quartz) #gives probability density distribution of the deposited quartz, based on the parameters you assigned above 
Deposit_sizes_quartz <- rnorm(1000, Deposit_mean_quartz, Deposit_sd_quartz) #randomly samples plot_size_max values given a mean and sd; result is a vector of possible deposited grains 
Deposit_sizes_quartz <- subset(Deposit_sizes_quartz, Deposit_sizes_quartz >0) #remove negative values 
Grains_quartz_combined$probability_deposited <- dnorm(Grains_quartz_combined$size, Deposit_mean_quartz, Deposit_sd_quartz) #given each grain's size, assign it some probability of being deposited based on the mean and sd of the deposit 

##Calculate size shift for non-quartz grains 

##Deposit in which the heavy minerals are the same size as the light minerals 
PDF_deposit_equal_heavies <- PDF_deposit_quartz
Deposit_sizes_equal_heavies <- rnorm(1000, Deposit_mean_quartz, Deposit_sd_quartz)
Deposit_sizes_equal_heavies <- subset(Deposit_sizes_equal_heavies, Deposit_sizes_equal_heavies >0) #remove negative values 

##Deposit equivalent to settling in water via Dietrich 1982 equation. 
#Note that this requires you've run the chunk "Dietrich settling" earlier in the code. 
#Deposit_sizes_quartz yields a vector of diameters of quartz grains that are being deposited, in microns
#We will solve for the dimensional settling velocity of these grains following the methods of Dietrich 1982
#Then, we will interpolate the dimensional grain sizes of zircons with the same settling velocities 
#First, use the deposited quartz to calculate the settling velocities of those grains 
Dstar_quartz_water_deposited <- dietrich_Dstar(Deposit_sizes_quartz/10000, rho_quartz, rho_water, kinematic_v_water) #convert grain size from microns to cm 
R1_quartz_water_deposited <- dietrich_R1(Dstar_quartz_water_deposited)
R2_quartz_water_deposited <- dietrich_R2(Dstar_quartz_water_deposited, CSF_quartz)
R3_quartz_water_deposited <- dietrich_R3(Dstar_quartz_water_deposited, CSF_quartz, P_quartz)
Wstar_quartz_water_deposited <- dietrich_final(R1_quartz_water_deposited, R2_quartz_water_deposited, R3_quartz_water_deposited)
W_quartz_water_deposited <- dietrich_w(Wstar_quartz_water_deposited, rho_quartz, rho_water, kinematic_v_water)
#Now use the relationship between grain size and settling velocity for zircon in water that we calculated earlier to interpolate what zircon grain size has the same settling velocity as that quartz  
Deposit_sizes_Dietrich_zircon_water <- approx(x = dietrich_data$zircon_water, y = dietrich_data$grain_diameter, xout = W_quartz_water_deposited)
Deposit_sizes_Dietrich_zircon_water <- Deposit_sizes_Dietrich_zircon_water$y

##Deposit equivalent to settling in water via Bagheri and Bonadonna 2016 equation. 
#Note that this requires you've run the chunk "Aeolian settling" earlier in the code. 
#First, interpolate settling velocities of the deposited quartz using the Bagheri + Bonadonna values calculated earlier. 
W_Bagheri_quartz_air <- approx(x =Bagheri_D_quartz_air, y = Bagheri_w_quartz_air, xout = Deposit_sizes_quartz)
W_Bagheri_quartz_air <- W_Bagheri_quartz_air$y 
#Now, interpolate the zircon size with that same settling velocity. 
Deposit_sizes_Bagheri_zircon_air <- approx(x = Bagheri_w_zircon_air, y = Bagheri_D_zircon_air, xout = W_Bagheri_quartz_air)
Deposit_sizes_Bagheri_zircon_air <- Deposit_sizes_Bagheri_zircon_air$y 

# Calculate predictions for "grain shielding case." The specific relationship here was quantified by Garzanti et al. 2008 based on observation of a modern aeolian dune. Garzanti et al. 2008 summarized the relationship with the Impact Law; we refer to this as the "grain shielding" or "gs" case.  
SSm <- log2((rho_zircon - rho_air)/(rho_quartz - rho_air)); #Expected size shift for zircon vs quartz in air, as given by the Impact Law in Garzanti et al. 2008 and defined from observation of an aeolian dune 
Deposit_sizes_zircon_gs_phi = -SSm + log2(Deposit_sizes_quartz/10000) # Solve for "log2(zircon size)", convert grain size to cm
Deposit_sizes_zircon_gs <- 2^(Deposit_sizes_zircon_gs_phi) # Move from log2(zircon size) to zircon size in cm
Deposit_sizes_zircon_gs <- Deposit_sizes_zircon_gs *10000 # convert to microns


##Fit a PDF to these deposits
PDF_deposit_zircon_gs <- fitdistr(Deposit_sizes_zircon_gs, densfun = "normal")
zircon_gs_mean <- PDF_deposit_zircon_gs$estimate[1]
zircon_gs_sd <- PDF_deposit_zircon_gs$estimate[2]
PDF_deposit_zircon_gs <- dnorm(1:plot_size_max, zircon_gs_mean, zircon_gs_sd)

PDF_deposit_zircon_Dietrich_water <- fitdistr(Deposit_sizes_Dietrich_zircon_water, densfun = "normal")
zircon_Dietrich_water_mean <- PDF_deposit_zircon_Dietrich_water$estimate[1]
zircon_Dietrich_water_sd <- PDF_deposit_zircon_Dietrich_water$estimate[2]
PDF_deposit_zircon_Dietrich_water  <- dnorm(1:plot_size_max, zircon_Dietrich_water_mean, zircon_Dietrich_water_sd)

PDF_deposit_zircon_Bagheri_air <- fitdistr(Deposit_sizes_Bagheri_zircon_air, densfun = "normal")
zircon_Bagheri_air_mean <- PDF_deposit_zircon_Bagheri_air$estimate[1]
zircon_Bagheri_air_sd <- PDF_deposit_zircon_Bagheri_air$estimate[2]
PDF_deposit_zircon_Bagheri_air  <- dnorm(1:plot_size_max, zircon_Bagheri_air_mean, zircon_Bagheri_air_sd)

PDF_deposit <- data.frame(PDF_deposit_quartz, PDF_deposit_equal_heavies, PDF_deposit_zircon_gs, PDF_deposit_zircon_Dietrich_water, PDF_deposit_zircon_Bagheri_air)
names(PDF_deposit) <- c("quartz", "equal_heavies","zircon_gs", "zircon_Dietrich_water", "zircon_Bagheri_air")

colors <- c("quartz" = 'black', "equal_heavies" = "chartreuse4", "zircon_gs" = 'coral3', "zircon_Dietrich_water" = 'blue', "zircon_Bagheri_air" = 'orange')
Deposited_grains_size_plot <-ggplot(PDF_deposit, x = 1:plot_size_max, ) + 
      geom_line(aes(x = 1:plot_size_max, y = quartz, color = "quartz"), size = .1)  +
      geom_line(aes(x = 1:plot_size_max, y = equal_heavies, color = "equal_heavies"), size = .5)  +
      geom_line(aes(x = 1:plot_size_max, y = zircon_gs, color = "zircon_gs"), size = .5)  +
      geom_line(aes(x = 1:plot_size_max, y = zircon_Dietrich_water, color = "zircon_Dietrich_water"), size = .5)  +
      geom_line(aes(x = 1:plot_size_max, y = zircon_Bagheri_air, color = "zircon_Bagheri_air"), size = .5)  +
 # theme(legend.position="top") +
   ggtitle('') +
      labs(x="grain size, microns", y="probability") +
      scale_y_continuous(limits = c(0, 0.16),
                     breaks = c(0, 0.08, 0.16),
                     expand = c(0,0),
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.08, 0.16)))+
        scale_x_continuous(limits = c(0, plot_size_max), 
                     expand = c(0,0),
                     sec.axis = sec_axis(trans=~.*1))+
        scale_color_manual(values = colors) +
        theme_bw() +
        theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 2/5.5,
           panel.grid.major = element_blank(),
           panel.grid.minor = element_blank(),
           panel.border  = element_rect(colour = "black", fill=NA, size=1),
           axis.line = element_line(colour = "black"),
           axis.title.y = element_blank(),
           axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
           axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
           axis.text.x.top = element_blank(), 
           axis.text.y.right = element_blank(), 
           axis.ticks = element_line(color = "black"),
           axis.ticks.x.top = element_line(color = "black"),
           axis.ticks.y.right = element_line(color = "black"),
           axis.ticks.length=unit(-0.25, "cm"),
           panel.background = element_blank(), 
           legend.position = "none")

#Find the probability of deposition for all grains given different size-density relationships
Grains_zircon_combined$probability_deposited_gs <- dnorm(Grains_zircon_combined$size, zircon_gs_mean, zircon_gs_sd)
Grains_zircon_combined$probability_deposited_equal_heavies <- dnorm(Grains_zircon_combined$size,  Deposit_mean_quartz, Deposit_sd_quartz) #this one is unusal--just uses the data from quartz 
Grains_zircon_combined$probability_deposited_Dietrich_water <- dnorm(Grains_zircon_combined$size, zircon_Dietrich_water_mean, zircon_Dietrich_water_sd)
Grains_zircon_combined$probability_deposited_Bagheri_air <- dnorm(Grains_zircon_combined$size, zircon_Bagheri_air_mean, zircon_Bagheri_air_sd)

# Define a function, synthetic_spectra, which will do random sampling of the measured zircons given an index of selections and a blank list and output a list of values 
synthetic_spectra1 <- function(index, list1, dataframe2use){ 
          for (n in 1:run.times) {
          set.seed(n) #set.seed here so that runs are reproducible
          index2use <- index[,n]
          deposited_grains <- dataframe2use[index2use, ] 
          individual_pdf <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=deposited_grains$age, sd=deposited_grains$age_uncert)
          summed_pdf <- rowSums (individual_pdf, na.rm = FALSE, dims = 1)
          summed_pdf <- summed_pdf / grains.in.run
          list1[[n]] <- summed_pdf
          list1[[run.times + n]] <- deposited_grains %>% dplyr::count(source)
          }
   return(list1)
  }

## Ok let's see what's deposited! 
run.times = 10000 #this defines how many spectra are generated for each one of the 4 size-density cases
grains.in.run = 100 #this defines how many grains are deposited in each run


###For quartz 
#randomly sample rows of the quartz grains available, based on the depositional PDF 
index_quartz <- replicate(run.times, sample(1:nrow(Grains_quartz_combined), grains.in.run, replace=FALSE, prob = Grains_quartz_combined$probability_deposited))

#Initialize lists before going into loop 
quartz.list <- list()

#Run synthetic spectra function
quartz.list <- synthetic_spectra1(index_quartz, quartz.list, Grains_quartz_combined)

#Turn list into dataframe
quartz.pdf = do.call(cbind, quartz.list[1:run.times])
quartz.sources = do.call(rbind, quartz.list[(run.times+1):(2*run.times)])

#Calculate quantiles 
quartz.quantiles <- data.frame(age.range, rowQuantiles(quartz.pdf, probs = c(.025, .50, 0.975)))
names(quartz.quantiles) <- c("age.range", "d025", "d50", "d975")

#Calculate source area 
quartz.sources <- quartz.sources %>% 
  group_by(source) %>% 
  summarise(n = sum(n))


###For equal heavies 
#randomly sample rows of the grains available, based on the depositional PDF 
index_equal_heavies <- replicate(run.times, sample(1:nrow(Grains_zircon_combined), grains.in.run, replace=FALSE, prob = Grains_zircon_combined$probability_deposited_equal_heavies))

#Initialize lists before going into loop 
equal_heavies.list <- list()

#Run synthetic spectra function
equal_heavies.list <- synthetic_spectra1(index_equal_heavies, equal_heavies.list, Grains_zircon_combined)

#Turn list into dataframe
equal_heavies.pdf = do.call(cbind, equal_heavies.list[1:run.times])
equal_heavies.sources = do.call(rbind, equal_heavies.list[(run.times+1):(2*run.times)])

#Calculate quantiles 
equal_heavies.quantiles <- data.frame(age.range, rowQuantiles(equal_heavies.pdf, probs = c(.025, .50, 0.975)))
names(equal_heavies.quantiles) <- c("age.range", "d025", "d50", "d975")

#Calculate source area 
equal_heavies.sources <- equal_heavies.sources %>% 
  group_by(source) %>% 
  summarise(n = sum(n))

###For Dietrich water
#randomly sample rows of the grains available, based on the depositional PDF 
index_Dietrich_water <- replicate(run.times, sample(1:nrow(Grains_zircon_combined), grains.in.run, replace=FALSE, prob = Grains_zircon_combined$probability_deposited_Dietrich_water))

#Initialize lists before going into loop 
Dietrich_water.list <- list()

#Run synthetic spectra function
Dietrich_water.list <- synthetic_spectra1(index_Dietrich_water, Dietrich_water.list, Grains_zircon_combined)

#Turn list into dataframe
Dietrich_water.pdf = do.call(cbind, Dietrich_water.list[1:run.times])
Dietrich_water.sources = do.call(rbind, Dietrich_water.list[(run.times+1):(2*run.times)])

#Calculate quantiles 
Dietrich_water.quantiles <- data.frame(age.range, rowQuantiles(Dietrich_water.pdf, probs = c(.025, .50, 0.975)))
names(Dietrich_water.quantiles) <- c("age.range", "d025", "d50", "d975")

#Calculate source area 
Dietrich_water.sources <- Dietrich_water.sources %>% 
  group_by(source) %>% 
  summarise(n = sum(n))

###For Bagheri air 
#randomly sample rows of the grains available, based on the depositional PDF 
index_Bagheri_air <- replicate(run.times, sample(1:nrow(Grains_zircon_combined), grains.in.run, replace=FALSE, prob = Grains_zircon_combined$probability_deposited_Bagheri_air))

#Initialize lists before going into loop 
Bagheri_air.list <- list()

#Run synthetic spectra function
Bagheri_air.list <- synthetic_spectra1(index_Bagheri_air, Bagheri_air.list, Grains_zircon_combined)

#Turn list into dataframe
Bagheri_air.pdf = do.call(cbind, Bagheri_air.list[1:run.times])
Bagheri_air.sources = do.call(rbind, Bagheri_air.list[(run.times+1):(2*run.times)])

#Calculate quantiles 
Bagheri_air.quantiles <- data.frame(age.range, rowQuantiles(Bagheri_air.pdf, probs = c(.025, .50, 0.975)))
names(Bagheri_air.quantiles) <- c("age.range", "d025", "d50", "d975")

#Calculate source area 
Bagheri_air.sources <- Bagheri_air.sources %>% 
  group_by(source) %>% 
  summarise(n = sum(n))

###For grain shielding
#randomly sample rows of the grains available, based on the depositional PDF 
index_gs <- replicate(run.times, sample(1:nrow(Grains_zircon_combined), grains.in.run, replace=FALSE, prob = Grains_zircon_combined$probability_deposited_gs))

#Initialize lists before going into loop 
gs.list <- list()

#Run synthetic spectra function
gs.list <- synthetic_spectra1(index_gs, gs.list, Grains_zircon_combined)

#Turn list into dataframe
gs.pdf = do.call(cbind, gs.list[1:run.times])
gs.sources = do.call(rbind, gs.list[(run.times+1):(2*run.times)])

#Calculate quantiles 
gs.quantiles <- data.frame(age.range, rowQuantiles(gs.pdf, probs = c(.025, .50, 0.975)))
names(gs.quantiles) <- c("age.range", "d025", "d50", "d975")

#Calculate source area 
gs.sources <- gs.sources %>% 
  group_by(source) %>% 
  summarise(n = sum(n))

#Plot the resulting age spectra for the four cases
Ages_zircons_equal_heavies <-ggplot() + 
    geom_line(equal_heavies.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = 'chartreuse4', alpha = 1, size = 0.25) + 
     geom_ribbon(equal_heavies.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = 'chartreuse4', alpha = .5) + 
    xlab('')+
    ylab('probability') +
    scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 0.012), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.006, 0.012), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.006, 0.012))) +   
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
   #scale_fill_manual(values=palette1[1]) +
    theme_bw() +
    theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1/4.7,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank(),
         plot.margin=unit(c(0,0,.5,0), "cm"))

Ages_zircons_Dietrich_water <-ggplot() + 
    geom_line(Dietrich_water.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = 'blue', alpha = 1, size = 0.25) + 
    geom_ribbon(Dietrich_water.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = 'blue', alpha = .5) + 
    xlab('')+
    ylab('probability') +
    scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 0.012), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.006, 0.012), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.006, 0.012))) +   
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
   theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
        aspect.ratio= 1/4.7,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank(),
        plot.margin=unit(c(0,0,.5,0), "cm"))


Ages_zircons_Bagheri_air <-ggplot() + 
    geom_line(Bagheri_air.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = 'orange', alpha = 1, size = 0.25) + 
     geom_ribbon(Bagheri_air.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = 'orange', alpha = .5) + 
    xlab('')+
    ylab('probability') +
    scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 0.012), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.006, 0.012), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.006, 0.012))) +   
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
   #scale_fill_manual(values=palette1[1]) +
   theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
        aspect.ratio= 1/4.7,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank(),
          plot.margin=unit(c(0,0,.5,0), "cm"))

Ages_zircons_gs <-ggplot() + 
      geom_line(gs.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = 'coral3', alpha = 1, size = 0.25) + 
     geom_ribbon(gs.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = 'coral3', alpha = .5) + 
      xlab('')+
      ylab('probability') +
      scale_y_continuous(expand = c(0,0), 
                     limits = c(0, 0.012), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.006, 0.012), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.006, 0.012))) +   
      scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000))) +
   #scale_fill_manual(values=palette1[1]) +
      theme_bw() +
      theme(text = element_text(family = "Helvetica", color = "black"),
    aspect.ratio= 1/4.7,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=1),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.background = element_blank(),
         plot.margin=unit(c(0,0,.5,0), "cm")) 

#Make pie charts for each of the four cases
colors <- c("S1" = palette1[1], "S2" = palette1[2])
#calculate position of labels for pie chart
quartz.sources <- quartz.sources %>%
  arrange(desc(source)) %>%
  mutate(prop = n / sum(quartz.sources$n) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )
#make pie chart
Pie_quartz_deposited <- ggplot(quartz.sources, aes(x="", y=prop, fill=source)) +
  geom_bar(stat="identity", width=1) +
  scale_fill_manual(values=colors) +
  coord_polar("y", start=0)+
  theme_void()+
  theme(legend.position="none",
        plot.title = element_text(size = 6),
        panel.background = element_blank()) +
  geom_text(aes(y = ypos, label = source), color = "white", size=4)+
  ggtitle('deposited quartz')


equal_heavies.sources <- equal_heavies.sources %>%
  arrange(desc(source)) %>%
  mutate(prop = n / sum(equal_heavies.sources$n) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )
#make pie chart
Pie_equal_heavies_deposited <- ggplot(equal_heavies.sources, aes(x="", y=prop, fill=source)) +
  geom_bar(stat="identity", width=1) +
  scale_fill_manual(values=colors) +
  coord_polar("y", start=0)+
  theme_void()+
  theme(legend.position="none",
        plot.title = element_text(size = 6),
        panel.background = element_blank()) +
  geom_text(aes(y = ypos, label = source), color = "white", size=4)+
  ggtitle('equal heavies')


Dietrich_water.sources <- Dietrich_water.sources %>%
  arrange(desc(source)) %>%
  mutate(prop = n / sum(Dietrich_water.sources$n) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )
#make pie chart
Pie_Dietrich_water_deposited <- ggplot(Dietrich_water.sources, aes(x="", y=prop, fill=source)) +
  geom_bar(stat="identity", width=1) +
  scale_fill_manual(values=colors) +
  coord_polar("y", start=0)+
  theme_void()+
  theme(legend.position="none",
        plot.title = element_text(size = 6),
        panel.background = element_blank()) +
  geom_text(aes(y = ypos, label = source), color = "white", size=4)+
  ggtitle('Dietrich_water')

Bagheri_air.sources <- Bagheri_air.sources %>%
  arrange(desc(source)) %>%
  mutate(prop = n / sum(Bagheri_air.sources$n) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )
#make pie chart
Pie_Bagheri_air_deposited <- ggplot(Bagheri_air.sources, aes(x="", y=prop, fill=source)) +
  geom_bar(stat="identity", width=1) +
  scale_fill_manual(values=colors) +
  coord_polar("y", start=0)+
  theme_void()+
  theme(legend.position="none",
        plot.title = element_text(size = 6),
        panel.background = element_blank()) +
  geom_text(aes(y = ypos, label = source), color = "white", size=4)+
  ggtitle('Bagheri_air')

gs.sources <- gs.sources %>%
  arrange(desc(source)) %>%
  mutate(prop = n / sum(gs.sources$n) *100) %>%
  mutate(ypos = cumsum(prop)- 0.5*prop )
#make pie chart
Pie_gs_deposited <- ggplot(gs.sources, aes(x="", y=prop, fill=source)) +
  geom_bar(stat="identity", width=1) +
  scale_fill_manual(values=colors) +
  coord_polar("y", start=0)+
  theme_void()+
  theme(legend.position="none",
        plot.title = element_text(size = 6),
        panel.background = element_blank()) +
  geom_text(aes(y = ypos, label = source), color = "white", size=4)+
  ggtitle('grain shielding')

#Plot Sources panel for small figure 
sources_small_plots <- grid.arrange(
  grobs = list(Sizes_grains_plot_S1, 
              Sizes_grains_plot_S2, 
              Ages_zircon_plot_S1, 
              Ages_zircon_plot_S2),
  widths = c(1,1),
  heights = c(1,1),
  layout_matrix = rbind(c(1, 3), 
                        c(2, 4)))
plot(sources_small_plots)
ggsave("Sources_Small_plot.pdf", sources_small_plots, width = 5, units = "in")


#Plot Depositional curve plot  
Deposited_grains_size_plot <- Deposited_grains_size_plot + theme(aspect.ratio= 1.5,   plot.margin=unit(c(0,0,.5,0), "cm")) 

ggsave("Deposit_curve_plot.pdf", Deposited_grains_size_plot, width = 3.75, height = 5.5, units = "cm")


combo_spectra_plot <- grid.arrange(
  grobs = list(Ages_zircons_equal_heavies, Ages_zircons_Dietrich_water, Ages_zircons_Bagheri_air,  Ages_zircons_gs),
  widths = c(1),
  heights = c(1/6,1,1,1,1),
  layout_matrix = rbind(c(NA),
                        c(4),
                        c(2),
                        c(3),
                        c(1)))
ggsave("Imaginary_spectra_plot.pdf", combo_spectra_plot, width = 6.5,  units = "cm")

combo_pie_plot <- grid.arrange(
  grobs = list(Pie_quartz_deposited, Pie_equal_heavies_deposited, Pie_Dietrich_water_deposited,Pie_Bagheri_air_deposited,  Pie_gs_deposited),
  widths = c(1),
  heights = c(1,1,1,1,1),
  layout_matrix = rbind(c(1),
                        c(5),
                        c(3),
                        c(4), 
                        c(2)))

ggsave("Pies_plot.pdf", combo_pie_plot, width = 5, height = 3.75, units = "in")


```

```{R Fig 5 Bridge figure, echo=FALSE}

#By repeatedly resampling the population of measured grains, we test the hypothesis that a shift in the Grenville peak can be replicated simply through changing grain size. 

# Define the age range of interest
age.range = 1:4000

# Set seed for reproducibility 
set.seed(1)

# Bring in colors for plotting
color_list <- brewer.pal(7,"Blues")

# Load data
Grain_data <- read.xls('Grain_data_Supplement_Size_and_Age_v03.xlsx',1, verbose=FALSE, skip = 0) 

# Trim data 
Grain_data <- Grain_data[,1:14]

# Rename columns 
names(Grain_data) <- c('spot_name', 'name2', 'analysisname', 'age207206', 'sd1_age207206', 'age238206', 'sd1_age238206', 'concordance', 'long_axis', 'short_axis', 'esd', 'bin', 'source', 'sample') #give columns names 

# Make sure columns are numeric
Grain_data$concordance <- as.numeric(as.character(Grain_data$concordance))
Grain_data$esd <- as.numeric(as.character(Grain_data$esd))
Grain_data$long_axis <- as.numeric(as.character(Grain_data$long_axis))
Grain_data$short_axis <- as.numeric(as.character(Grain_data$short_axis))
Grain_data$age207206 <- as.numeric(as.character(Grain_data$age207206))
Grain_data$sd1_age207206 <- as.numeric(as.character(Grain_data$sd1_age207206))
Grain_data$age238206 <- as.numeric(as.character(Grain_data$age238206))
Grain_data$sd1_age238206 <- as.numeric(as.character(Grain_data$sd1_age238206))

#remove samples with discordance > 10% absolute value 
#This is manually calculated for Cantine and Schoenborn samples. Muhlbauer samples are all concordant.
Grain_data <- subset(Grain_data, abs(Grain_data$concordance) < 0.1)

# Now we are working towards a PDF for the entire population of zircons 
# First, calculate the PDF for each individual zircon 
PDF_zircon_all <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=Grain_data$age207206, sd=Grain_data$sd1_age207206)
# Sum them 
PDF_zircon_all <- rowSums(PDF_zircon_all, na.rm = FALSE, dims = 1)
# Divide by the total number of zircons 
PDF_zircon_all <- PDF_zircon_all / nrow(Grain_data)
# Put into a dataframe for plotting 
PDF_zircon_all<- data.frame(age.range, PDF_zircon_all)

# Generate a plot of the PDF for all zircons 
Ages_zircon_plot_all <-ggplot(PDF_zircon_all) + 
  geom_line(aes(x = age.range, y = PDF_zircon_all), size = .5)  +
   ggtitle('Age spectra') +
  xlab('')+
  ylab('probability') +
  scale_y_continuous(labels = scales::number_format(accuracy = 0.001),
                     expand = c(0,0), 
                     breaks = c(0, 0.003, 0.006), 
                     limits = c(0, 0.006), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.003, 0.006))) +
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000), 
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000)))+ 
  theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 2/5.5,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.margin=unit(c(.25,.25,.25,.25), "cm"))  


# We'd also like to generate a histogram of the grain sizes of all the zircon grains 
Rainstorm_size_plot  <- ggplot(Grain_data, aes(x=long_axis)) + geom_histogram(binwidth = 2) +
  #   theme(aspect.ratio=1) + 
  ggtitle('Zircon sizes, measured') +
  xlab('diameter, um')+
  ylab('')  +
 #  scale_fill_manual(values=palette1[1]) +
    scale_y_continuous(expand = c(0,0), 
                       limits = c(0, 20),
                       breaks = c(0, 10, 20),
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 10, 20))) +
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 400),
                       sec.axis = sec_axis(trans=~.*1)) +
  theme_bw() +
   theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 2/5.5,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank(),
         plot.margin=unit(c(.25,.25,.25,.25), "cm"))



# Now let's work towards defining the PDFs that we will use to "deposit" grains 

#First, we define some useful constants
plot_size_max = 400 #the xmax in the plot of curves we will make 
run.times = 10000 #how many times you want to do the random sampling
grains.in.run <- 60 #how many grains to pull in each run 

#Define several deposited curves 
##case 1
case1.mean <- 69 #approximate mean and stdev of crystal fans, long axis
case1.sd <- 16

##case 2
case2.mean <- 89 #approximate mean and stdev of Rainstorm sandstone, long axis
case2.sd <- 21

##case 3
case3.mean <- 124 #approximate mean and stdev of Lower Johnnie, long axis
case3.sd <- 32

##case 4
case4.mean <- 154 #approximate mean and stdev of Wood Canyon Fm, long axis
case4.sd <- 50

PDF_deposit_case1 <- dnorm(1:plot_size_max, case1.mean, case1.sd) #calculate density function given case 1 parameters
Grain_data$probability_deposited_case1 <- dnorm(Grain_data$long_axis, case1.mean, case1.sd) #give vector of probability of deposition for each grain given parameters in case 1

PDF_deposit_case2 <- dnorm(1:plot_size_max, case2.mean, case2.sd) #calculate density function given case 2 parameters
Grain_data$probability_deposited_case2 <- dnorm(Grain_data$long_axis, case2.mean, case2.sd) #give vector of probability of deposition for each grain given parameters in case 2

PDF_deposit_case3 <- dnorm(1:plot_size_max, case3.mean, case3.sd) #calculate density function given case 3 parameters
Grain_data$probability_deposited_case3 <- dnorm(Grain_data$long_axis, case3.mean, case3.sd) #give vector of probability of deposition for each grain given parameters in case 3

PDF_deposit_case4 <- dnorm(1:plot_size_max, case4.mean, case4.sd) #calculate density function given case 4 parameters
Grain_data$probability_deposited_case4 <- dnorm(Grain_data$long_axis, case4.mean, case4.sd) #give vector of probability of deposition for each grain given parameters in case 4

#Put all deposit probability density functions into a data frame for plotting 
deposit.curves <- data.frame(PDF_deposit_case1, PDF_deposit_case2, PDF_deposit_case3, PDF_deposit_case4)

#Plot all of the probability density functions defining depositional grain size 
Deposit_curves_plot <-ggplot(deposit.curves, x = 1:plot_size_max) + 
    geom_line(aes(x = 1:plot_size_max, y = PDF_deposit_case1), size = .5, color = color_list[4])  +
    geom_line(aes(x = 1:plot_size_max, y = PDF_deposit_case2), size = .5, color = color_list[5])  +
    geom_line(aes(x = 1:plot_size_max, y = PDF_deposit_case3), size = .5, color = color_list[6])  +
    geom_line(aes(x = 1:plot_size_max, y = PDF_deposit_case4), size = .5, color = color_list[7])  +
    ggtitle('') +
    labs(x="grain size, microns", y="probability") +
    scale_y_continuous(limits = c(0, 0.03), expand = c(0,0), sec.axis = sec_axis(trans=~.*1))+
    scale_x_continuous(limits = c(0, plot_size_max), expand = c(0,0), sec.axis = sec_axis(trans=~.*1))+
    scale_color_manual(values = colors) +
    theme_bw() +
    theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 5.5/4,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),  
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         panel.background = element_blank())

# Define a function, synthetic_spectra, which will do random sampling of the measured zircons given an index of selections and a blank list and output a list of values 
synthetic_spectra <- function(index, list1){ 
          for (n in 1:run.times) {
          set.seed(n) #set.seed here so that runs are reproducible
          index2use <- index[,n]
          deposited_zircons <- Grain_data[index2use, ] 
          individual_pdf <- mapply(function(mean,sd) dnorm(age.range,mean,sd), mean=deposited_zircons$age207206, sd=deposited_zircons$sd1_age207206)
          summed_pdf <- rowSums (individual_pdf, na.rm = FALSE, dims = 1)
          summed_pdf <- summed_pdf / grains.in.run
          list1[[n]] <- summed_pdf
          }
   return(list1)
  }



## Ok, now let's see what's deposited! 

#case 1 
#randomly sample rows of the quartz grains available, based on the depositional PDF 
index_zircon_case1 <- replicate(run.times, sample(1:nrow(Grain_data), size = grains.in.run, replace=FALSE, prob = Grain_data$probability_deposited_case1))

#Initialize lists before going into loop 
case1.list <- list()

#Run synthetic spectra function
case1.list <- synthetic_spectra(index_zircon_case1, case1.list)

#Turn list into dataframe
case1.pdf = do.call(cbind, case1.list)

#Extract quantiles for plotting
case1.quantiles <- data.frame(age.range, rowQuantiles(case1.pdf, probs = c(.025, .50, 0.975)))
names(case1.quantiles) <- c("age.range", "d025", "d50", "d975")

#case 2 
#randomly sample rows of the quartz grains available, based on the depositional PDF 
index_zircon_case2 <- replicate(run.times, sample(1:nrow(Grain_data), size = grains.in.run, replace=FALSE, prob = Grain_data$probability_deposited_case2))

#Initialize lists before going into loop 
case2.list <- list()

#Run synthetic spectra function
case2.list <- synthetic_spectra(index_zircon_case2, case2.list)

#Turn list into dataframe
case2.pdf = do.call(cbind, case2.list)

#Extract quantiles for plotting
case2.quantiles <- data.frame(age.range, rowQuantiles(case2.pdf, probs = c(.025, .50, 0.975)))
names(case2.quantiles) <- c("age.range", "d025", "d50", "d975")

#case 3 
#randomly sample rows of the quartz grains available, based on the depositional PDF 
index_zircon_case3 <- replicate(run.times, sample(1:nrow(Grain_data), size = grains.in.run, replace=FALSE, prob = Grain_data$probability_deposited_case3))

#Initialize lists before going into loop 
case3.list <- list()

#Run synthetic spectra function
case3.list <- synthetic_spectra(index_zircon_case3, case3.list)

#Turn list into dataframe
case3.pdf = do.call(cbind, case3.list)

#Extract quantiles for plotting
case3.quantiles <- data.frame(age.range, rowQuantiles(case3.pdf, probs = c(.025, .50, 0.975)))
names(case3.quantiles) <- c("age.range", "d025", "d50", "d975")

#case 4 
#randomly sample rows of the quartz grains available, based on the depositional PDF 
index_zircon_case4 <- replicate(run.times, sample(1:nrow(Grain_data), size = grains.in.run, replace=FALSE, prob = Grain_data$probability_deposited_case4))

#Initialize lists before going into loop 
case4.list <- list()

#Run synthetic spectra function
case4.list <- synthetic_spectra(index_zircon_case4, case4.list)

#Turn list into dataframe
case4.pdf = do.call(cbind, case4.list)

#Extract quantiles for plotting
case4.quantiles <- data.frame(age.range, rowQuantiles(case4.pdf, probs = 0.025), rowQuantiles(case4.pdf, probs = 0.5), rowQuantiles(case4.pdf, probs = 0.975))
names(case4.quantiles) <- c("age.range", "d025", "d50", "d975")


#Plot data and generate plot files 

Ages_zircons_case1 <-ggplot() + 
  geom_line(case1.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = color_list[4], alpha = 1, size = 0.1) + 
  geom_ribbon(case1.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = color_list[4], alpha = .5) + 
  xlab('')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 0.006), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.003, 0.006), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.003, 0.006))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000), 
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000)))+  
    theme_bw() +
     theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1/6,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         plot.margin=unit(c(.25,.25,.25,.25), "cm")) 




Ages_zircons_case2 <-ggplot() + 
          geom_line(case2.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = color_list[5], alpha = 1, size = 0.1) + 
      geom_ribbon(case2.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = color_list[5], alpha = .5) + 
  xlab('')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 0.006), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.003, 0.006), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.003, 0.006))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000), 
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000)))+ 
    theme_bw() +
     theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1/6,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),
         axis.line = element_line(colour = "black"),
         axis.title.y = element_blank(),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         plot.margin=unit(c(.25,.25,.25,.25), "cm"))


Ages_zircons_case3 <-ggplot() + 
       geom_line(data = case3.quantiles, mapping = aes(x =age.range, y =d50), color = color_list[6], alpha = 1, size = 0.1) + 
      geom_ribbon(case3.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = color_list[6], alpha = .5) + 
  xlab('')+
  scale_y_continuous(expand = c(0,0), limits = c(0, 0.006), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.003, 0.006), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.003, 0.006))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000), 
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000)))+ 
    theme_bw() +
     theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1/6,
           panel.grid.major = element_blank(),
           panel.grid.minor = element_blank(),
           panel.border  = element_rect(colour = "black", fill=NA, size=.5),
           axis.line = element_line(colour = "black"),
           axis.title.y = element_blank(),
           axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
           axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
           axis.text.x.top = element_blank(), 
           axis.text.y.right = element_blank(), 
           axis.ticks = element_line(color = "black"),
           axis.ticks.x.top = element_line(color = "black"),
           axis.ticks.y.right = element_line(color = "black"),
           axis.ticks.length=unit(-0.25, "cm"),
           plot.margin=unit(c(.25,.25,.25,.25), "cm"))

Ages_zircons_case4 <-ggplot() + 
      geom_line(case4.quantiles, mapping = aes(x = age.range, y =d50), inherit.aes = FALSE, color = color_list[7], alpha = 1, size = 0.1) + 
      geom_ribbon(case4.quantiles, mapping = aes(x = age.range, ymin =d025, ymax =d975), inherit.aes = FALSE, fill = color_list[7], alpha = .5) + 
      xlab('')+
    scale_y_continuous(expand = c(0,0), limits = c(0, 0.006), 
                     labels = scales::number_format(accuracy = 0.001), 
                     breaks = c(0, 0.003, 0.006), 
                     sec.axis = sec_axis(trans=~.*1, breaks = c(0, 0.003, 0.006))) +  
    scale_x_continuous(expand = c(0,0), 
                       limits = c(0, 2000), 
                       breaks = c(0, 1000, 2000), 
                       sec.axis = sec_axis(trans=~.*1, breaks = c(0, 1000, 2000)))+  
    theme_bw() +
     theme(text = element_text(family = "Helvetica", color = "black"),
           aspect.ratio= 1/6,
         panel.grid.major = element_blank(),
         panel.grid.minor = element_blank(),
         panel.border  = element_rect(colour = "black", fill=NA, size=.5),
         axis.line = element_line(colour = "black"),
         axis.text.x = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5, 0.5,0.5), "cm")),
         axis.text.y = element_text(color = 'black', size = 10, margin=unit(c(0.5, 0.5,0.5,0.5), "cm")),
         axis.title.y = element_blank(),
         axis.text.x.top = element_blank(), 
         axis.text.y.right = element_blank(), 
         axis.ticks = element_line(color = "black"),
         axis.ticks.x.top = element_line(color = "black"),
         axis.ticks.y.right = element_line(color = "black"),
         axis.ticks.length=unit(-0.25, "cm"),
         plot.margin=unit(c(.25,.25,.25,.25), "cm"))

plot(Ages_zircon_plot_all)
plot(Rainstorm_size_plot)
plot(Deposit_curves_plot)

combo_plot <- grid.arrange(
  grobs = list(Ages_zircons_case1, Ages_zircons_case2, Ages_zircons_case3,  Ages_zircons_case4),
  widths = c(1),
  heights = c(1,1,1,1),
  layout_matrix = rbind(c(1),
                        c(2),
                        c(3),
                        c(4))
)

real_data_plot <- grid.arrange(
  grobs = list(Ages_zircon_plot_all, Rainstorm_size_plot),
  widths = c(1),
  heights = c(1,1),
  layout_matrix = rbind(c(1),
                        c(2))
)


ggsave("Grain_data_all.pdf", real_data_plot, units = "in")
ggsave("Size_testing.pdf", combo_plot, width = 5, units = "in")
ggsave("Size_testing_deposit_curve.pdf", Deposit_curves_plot, width = 3.75, height = 5, units = "in")

# 

```
```{r Integrations}


##This section calculates the area under the curve within the "Grenvillle" boundaries (1000-1200 Ma) for each of several cases. 


#Find area under curve for synthetic spectra. 
case1_gren_lo <- auc(case1.quantiles$age.range, 
                     case1.quantiles$d025,
                     from = 1000, 
                     to = 1200)
case1_gren_hi <- auc(case1.quantiles$age.range, 
                     case1.quantiles$d975,
                     from = 1000, 
                     to = 1200)
case2_gren_lo <- auc(case2.quantiles$age.range, 
                     case2.quantiles$d025,
                     from = 1000, 
                     to = 1200)
case2_gren_hi <- auc(case2.quantiles$age.range, 
                     case2.quantiles$d975,
                     from = 1000, 
                     to = 1200)
case3_gren_lo <- auc(case3.quantiles$age.range, 
                     case3.quantiles$d025,
                     from = 1000, 
                     to = 1200)
case3_gren_hi <- auc(case3.quantiles$age.range, 
                     case3.quantiles$d975,
                     from = 1000, 
                     to = 1200)
case4_gren_lo <- auc(case4.quantiles$age.range, 
                     case4.quantiles$d025,
                     from = 1000, 
                     to = 1200)
case4_gren_hi <- auc(case4.quantiles$age.range, 
                     case4.quantiles$d975,
                     from = 1000, 
                     to = 1200)

#Find area under curve for real data. 
#Lower Johnnie Fm
age_range = 0:4000
LowerJohnnie <- subset(Grain_data, Grain_data$bin=="LowerJohnnie")
PDF_LowerJohnnie <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=LowerJohnnie$age207206, sd=LowerJohnnie$sd1_age207206)
PDF_LowerJohnnie <- rowSums(PDF_LowerJohnnie, na.rm = FALSE, dims = 1)
PDF_LowerJohnnie <- PDF_LowerJohnnie / nrow(LowerJohnnie) 
PDF_LowerJohnnie <- data.frame(age_range, PDF_LowerJohnnie)
LowerJohnnie_gren <- auc(PDF_LowerJohnnie$age_range, 
                     PDF_LowerJohnnie$PDF_LowerJohnnie,
                     from = 1000, 
                     to = 1200) 

#Mid Johnnie Fm
age_range = 0:4000
MidJohnnie <- subset(Grain_data, Grain_data$bin=="MidJohnnie")
PDF_MidJohnnie <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=MidJohnnie$age207206, sd=MidJohnnie$sd1_age207206)
PDF_MidJohnnie <- rowSums(PDF_MidJohnnie, na.rm = FALSE, dims = 1)
PDF_MidJohnnie <- PDF_MidJohnnie / nrow(MidJohnnie) 
PDF_MidJohnnie <- data.frame(age_range, PDF_MidJohnnie)
MidJohnnie_gren <- auc(PDF_MidJohnnie$age_range, 
                     PDF_MidJohnnie$PDF_MidJohnnie,
                     from = 1000, 
                     to = 1200) 

#Rainstorm sst 
age_range = 0:4000
Rainstormsst <- subset(Grain_data, Grain_data$bin=="Rainstormsst" )
PDF_Rainstormsst <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=Rainstormsst$age207206, sd=Rainstormsst$sd1_age207206)
PDF_Rainstormsst <- rowSums(PDF_Rainstormsst, na.rm = FALSE, dims = 1)
PDF_Rainstormsst <- PDF_Rainstormsst / nrow(Rainstormsst) 
PDF_Rainstormsst <- data.frame(age_range, PDF_Rainstormsst)
Rainstormsst_gren <- auc(PDF_Rainstormsst$age_range, 
                     PDF_Rainstormsst$PDF_Rainstormsst,
                     from = 1000, 
                     to = 1200) 


#Crystal fans 
age_range = 0:4000
Crystalfan <- subset(Grain_data, Grain_data$bin=="Crystalfan")
PDF_Crystalfan <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=Crystalfan$age207206, sd=Crystalfan$sd1_age207206)
PDF_Crystalfan <- rowSums(PDF_Crystalfan, na.rm = FALSE, dims = 1)
PDF_Crystalfan <- PDF_Crystalfan / nrow(Crystalfan) 
PDF_Crystalfan <- data.frame(age_range, PDF_Crystalfan)
Crystalfan_gren <- auc(PDF_Crystalfan$age_range, 
                     PDF_Crystalfan$PDF_Crystalfan,
                     from = 1000, 
                     to = 1200) 

#Lower Stirling
age_range = 0:4000
LowerStirling <- subset(Grain_data, Grain_data$bin=="LowerStirling")
PDF_LowerStirling <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=LowerStirling$age207206, sd=LowerStirling$sd1_age207206)
PDF_LowerStirling <- rowSums(PDF_LowerStirling, na.rm = FALSE, dims = 1)
PDF_LowerStirling <- PDF_LowerStirling / nrow(LowerStirling) 
PDF_LowerStirling <- data.frame(age_range, PDF_LowerStirling)
LowerStirling_gren <- auc(PDF_LowerStirling$age_range, 
                     PDF_LowerStirling$PDF_LowerStirling,
                     from = 1000, 
                     to = 1200) 

#Upper Stirling
age_range = 0:4000
UpperStirling <- subset(Grain_data, Grain_data$bin=="UpperStirling")
PDF_UpperStirling <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=UpperStirling$age207206, sd=UpperStirling$sd1_age207206)
PDF_UpperStirling <- rowSums(PDF_UpperStirling, na.rm = FALSE, dims = 1)
PDF_UpperStirling <- PDF_UpperStirling / nrow(UpperStirling) 
PDF_UpperStirling <- data.frame(age_range, PDF_UpperStirling)
UpperStirling_gren <- auc(PDF_UpperStirling$age_range, 
                     PDF_UpperStirling$PDF_UpperStirling,
                     from = 1000, 
                     to = 1200) 

#Stirling Quartzite Muhlbauer
age_range = 0:4000
UpperStirling2 <- subset(Grain_data, Grain_data$bin=="StirlingQuartziteMuhlbauer")
PDF_UpperStirling2 <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=UpperStirling2$age207206, sd=UpperStirling2$sd1_age207206)
PDF_UpperStirling2 <- rowSums(PDF_UpperStirling2, na.rm = FALSE, dims = 1)
PDF_UpperStirling2 <- PDF_UpperStirling2 / nrow(UpperStirling2) 
PDF_UpperStirling2 <- data.frame(age_range, PDF_UpperStirling2)
UpperStirling2_gren <- auc(PDF_UpperStirling2$age_range, 
                     PDF_UpperStirling2$PDF_UpperStirling2,
                     from = 1000, 
                     to = 1200) 


#Wood Canyon Fm
age_range = 0:4000
WoodCanyon <- subset(Grain_data, Grain_data$bin=="WoodCanyon")
PDF_WoodCanyon <- mapply(function(mean,sd) dnorm(age_range,mean,sd), mean=WoodCanyon$age207206, sd=WoodCanyon$sd1_age207206)
PDF_WoodCanyon <- rowSums(PDF_WoodCanyon, na.rm = FALSE, dims = 1)
PDF_WoodCanyon <- PDF_WoodCanyon / nrow(WoodCanyon) 
PDF_WoodCanyon <- data.frame(age_range, PDF_WoodCanyon)
WoodCanyon_gren <- auc(PDF_WoodCanyon$age_range, 
                     PDF_WoodCanyon$PDF_WoodCanyon,
                     from = 1000, 
                     to = 1200) 




```
